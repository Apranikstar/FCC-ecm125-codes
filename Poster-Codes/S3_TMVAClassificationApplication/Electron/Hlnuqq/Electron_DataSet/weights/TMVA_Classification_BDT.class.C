// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.32/00       [401408]
Creator        : apranikstar
Date           : Mon Dec  9 18:23:28 2024
Host           : Darwin ChristoersMBP72.localdomain 23.5.0 Darwin Kernel Version 23.5.0: Wed May 1 20:12:58 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6000 arm64
Dir            : /Users/apranikstar/Desktop/FCC_Presentation/TMVAClassification/Electron/Hlnuqq
Training events: 349052
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "2" [Max depth of the decision tree allowed]
MinNodeSize: "0.5" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "6.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "7" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 52
Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       F                                 'F'    [-5.25497627258,5.12944602966]
Delta_rapidity_electron_JNLO  Delta_rapidity_electron_JNLO  Delta_rapidity_electron_JNLO  Delta_rapidity_electron_JNLO  F                                 'F'    [-5.17370891571,5.12944602966]
Delta_rapidity_electron_JLO   Delta_rapidity_electron_JLO   Delta_rapidity_electron_JLO   Delta_rapidity_electron_JLO   F                                 'F'    [-5.10341596603,5.25497627258]
JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               F                                 'F'    [-2.99912524223,2.99661111832]
JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                F                                 'F'    [-2.76398515701,2.88360857964]
electron_Rapidity             electron_Rapidity             electron_Rapidity             electron_Rapidity             F                                 'F'    [-2.56099104881,2.56050848961]
Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            F                                 'F'    [-6.78954601288,6.24849843979]
Delta_eta_electron_NJO        Delta_eta_electron_NJO        Delta_eta_electron_NJO        Delta_eta_electron_NJO        F                                 'F'    [-5.60817861557,5.42680549622]
Delta_eta_electron_JLO        Delta_eta_electron_JLO        Delta_eta_electron_JLO        Delta_eta_electron_JLO        F                                 'F'    [-5.10341882706,5.46918869019]
JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    F                                 'F'    [-4.42398834229,4.47162628174]
JetLO_eta                     JetLO_eta                     JetLO_eta                     JetLO_eta                     F                                 'F'    [-3.94285011292,3.69787573814]
electron_eta                  electron_eta                  electron_eta                  electron_eta                  F                                 'F'    [-2.56099152565,2.56050944328]
PT_electron                   PT_electron                   PT_electron                   PT_electron                   F                                 'F'    [1.6010761261,52.4370269775]
PT_JNLO                       PT_JNLO                       PT_JNLO                       PT_JNLO                       F                                 'F'    [1.00016665459,48.6934051514]
PT_JLO                        PT_JLO                        PT_JLO                        PT_JLO                        F                                 'F'    [1.30636429787,52.4370269775]
Energy_Transverse_electron    Energy_Transverse_electron    Energy_Transverse_electron    Energy_Transverse_electron    F                                 'F'    [1.6010761261,52.4370231628]
Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        F                                 'F'    [1.00030720234,52.2588272095]
Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         F                                 'F'    [1.36527431011,52.4435081482]
Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         F                                 'F'    [0.0844395533204,55.6596832275]
Energy_electron               Energy_electron               Energy_electron               Energy_electron               F                                 'F'    [10.000087738,52.4495048523]
Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   F                                 'F'    [1.00717115402,52.4497108459]
Energy_JLO                    Energy_JLO                    Energy_JLO                    Energy_JLO                    F                                 'F'    [2.09530735016,52.449962616]
M_JLO                         M_JLO                         M_JLO                         M_JLO                         F                                 'F'    [-0.0287605766207,40.4045715332]
M_JNLO                        M_JNLO                        M_JNLO                        M_JNLO                        F                                 'F'    [-0.0268572345376,40.2533836365]
M_electron                    M_electron                    M_electron                    M_electron                    F                                 'F'    [-0.0287605766207,0.0280456580222]
M_met                         M_met                         M_met                         M_met                         F                                 'F'    [-0.0204557608813,0.0211179815233]
MT_electron                   MT_electron                   MT_electron                   MT_electron                   F                                 'F'    [1.60107779503,52.4370231628]
MT_JNLO                       MT_JNLO                       MT_JNLO                       MT_JNLO                       F                                 'F'    [1.00030720234,52.2707824707]
MT_JLO                        MT_JLO                        MT_JLO                        MT_JLO                        F                                 'F'    [2.06876635551,52.4439582825]
MT_met                        MT_met                        MT_met                        MT_met                        F                                 'F'    [0.08340485394,55.6596832275]
Phi_electron                  Phi_electron                  Phi_electron                  Phi_electron                  F                                 'F'    [-3.14158439636,3.14159035683]
Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      F                                 'F'    [-3.14157986641,3.14159035683]
Phi_JLO                       Phi_JLO                       Phi_JLO                       Phi_JLO                       F                                 'F'    [-3.14157772064,3.14155697823]
Theta_electron                Theta_electron                Theta_electron                Theta_electron                F                                 'F'    [0.154224321246,2.98744225502]
Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    F                                 'F'    [0.0228564329445,3.1176211834]
Theta_JLO                     Theta_JLO                     Theta_JLO                     Theta_JLO                     F                                 'F'    [0.0495420657098,3.10281181335]
cosTheta_electron             cosTheta_electron             cosTheta_electron             cosTheta_electron             F                                 'F'    [-0.988142371178,0.988130986691]
cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 F                                 'F'    [-0.999712705612,0.999738812447]
cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  F                                 'F'    [-0.999248087406,0.998773038387]
CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             F                                 'F'    [-0.999998867512,0.0747421830893]
CosAngle_Electron_JNLO        CosAngle_Electron_JNLO        CosAngle_Electron_JNLO        CosAngle_Electron_JNLO        F                                 'F'    [-0.999992311001,1]
CosAngle_Electron_JLO         CosAngle_Electron_JLO         CosAngle_Electron_JLO         CosAngle_Electron_JLO         F                                 'F'    [-0.999998867512,1]
Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             F                                 'F'    [5.44996403562e-08,0.499174982309]
Aplanarity                    Aplanarity                    Aplanarity                    Aplanarity                    F                                 'F'    [-5.28478784748e-16,0.152779623866]
Sphericity                    Sphericity                    Sphericity                    Sphericity                    F                                 'F'    [8.17494623107e-08,0.805859208107]
DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             F                                 'F'    [-3.14157986641,3.14159226418]
DeltaPhi_electron_JNLO        DeltaPhi_electron_JNLO        DeltaPhi_electron_JNLO        DeltaPhi_electron_JNLO        F                                 'F'    [-3.14150571823,3.14158248901]
DeltaPhi_electron_JLO         DeltaPhi_electron_JLO         DeltaPhi_electron_JLO         DeltaPhi_electron_JLO         F                                 'F'    [-3.14153814316,3.14155483246]
DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               F                                 'F'    [1.50067317486,6.90080404282]
DeltaR_electron_JLO           DeltaR_electron_JLO           DeltaR_electron_JLO           DeltaR_electron_JLO           F                                 'F'    [0,5.81104850769]
DeltaR_electron_JNLO          DeltaR_electron_JNLO          DeltaR_electron_JNLO          DeltaR_electron_JNLO          F                                 'F'    [0,5.98383140564]
Energy_MET                    Energy_MET                    Energy_MET                    Energy_MET                    F                                 'F'    [20.0000591278,55.878112793]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTNode

#ifndef BDTNode__def
#define BDTNode__def

class BDTNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 52 )
   {
      // the training input variables
      const char* inputVars[] = { "Delta_rapidity_JNLO_JLO", "Delta_rapidity_electron_JNLO", "Delta_rapidity_electron_JLO", "JetNLO_Rapidity", "JetLO_Rapidity", "electron_Rapidity", "Delta_eta_JLO_JNLO", "Delta_eta_electron_NJO", "Delta_eta_electron_JLO", "JetNLO_eta", "JetLO_eta", "electron_eta", "PT_electron", "PT_JNLO", "PT_JLO", "Energy_Transverse_electron", "Energy_Transverse_JNLO", "Energy_Transverse_JLO", "Energy_Transverse_met", "Energy_electron", "Energy_JNLO", "Energy_JLO", "M_JLO", "M_JNLO", "M_electron", "M_met", "MT_electron", "MT_JNLO", "MT_JLO", "MT_met", "Phi_electron", "Phi_JNLO", "Phi_JLO", "Theta_electron", "Theta_JNLO", "Theta_JLO", "cosTheta_electron", "cosTheta_JNLO", "cosTheta_JLO", "CosAngle_JNLO_JLO", "CosAngle_Electron_JNLO", "CosAngle_Electron_JLO", "Linear_Aplanarity", "Aplanarity", "Sphericity", "DeltaPhi_JNLO_JLO", "DeltaPhi_electron_JNLO", "DeltaPhi_electron_JLO", "DeltaR_JNLO_JLO", "DeltaR_electron_JLO", "DeltaR_electron_JNLO", "Energy_MET" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;
      fVmin[29] = 0;
      fVmax[29] = 0;
      fVmin[30] = 0;
      fVmax[30] = 0;
      fVmin[31] = 0;
      fVmax[31] = 0;
      fVmin[32] = 0;
      fVmax[32] = 0;
      fVmin[33] = 0;
      fVmax[33] = 0;
      fVmin[34] = 0;
      fVmax[34] = 0;
      fVmin[35] = 0;
      fVmax[35] = 0;
      fVmin[36] = 0;
      fVmax[36] = 0;
      fVmin[37] = 0;
      fVmax[37] = 0;
      fVmin[38] = 0;
      fVmax[38] = 0;
      fVmin[39] = 0;
      fVmax[39] = 0;
      fVmin[40] = 0;
      fVmax[40] = 0;
      fVmin[41] = 0;
      fVmax[41] = 0;
      fVmin[42] = 0;
      fVmax[42] = 0;
      fVmin[43] = 0;
      fVmax[43] = 0;
      fVmin[44] = 0;
      fVmax[44] = 0;
      fVmin[45] = 0;
      fVmax[45] = 0;
      fVmin[46] = 0;
      fVmax[46] = 0;
      fVmin[47] = 0;
      fVmax[47] = 0;
      fVmin[48] = 0;
      fVmax[48] = 0;
      fVmin[49] = 0;
      fVmax[49] = 0;
      fVmin[50] = 0;
      fVmax[50] = 0;
      fVmin[51] = 0;
      fVmax[51] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';
      fType[29] = 'F';
      fType[30] = 'F';
      fType[31] = 'F';
      fType[32] = 'F';
      fType[33] = 'F';
      fType[34] = 'F';
      fType[35] = 'F';
      fType[36] = 'F';
      fType[37] = 'F';
      fType[38] = 'F';
      fType[39] = 'F';
      fType[40] = 'F';
      fType[41] = 'F';
      fType[42] = 'F';
      fType[43] = 'F';
      fType[44] = 'F';
      fType[45] = 'F';
      fType[46] = 'F';
      fType[47] = 'F';
      fType[48] = 'F';
      fType[49] = 'F';
      fType[50] = 'F';
      fType[51] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[52];
   double fVmax[52];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[52];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.88607453460546);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.979807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284598,-99) , 
41, -0.741893, 0, 0, 0.948828,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.765726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0308766,-99) , 
39, -0.689129, 0, 0, 0.098058,-99) , 
18, 16.0628, 0, 0, 0.492984,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.40229);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.96617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483719,-99) , 
39, -0.758202, 0, 0, 0.886654,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.87556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0653379,-99) , 
19, 30.5395, 0, 0, 0.12685,-99) , 
18, 14.4264, 0, 0, 0.490635,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.12393);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.853913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.305267,-99) , 
45, 2.93888, 1, 0, 0.790134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.836764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0656453,-99) , 
22, 3.6309, 1, 0, 0.0915193,-99) , 
18, 7.29419, 0, 0, 0.560693,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.890415);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.776486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.232733,-99) , 
45, -2.9389, 0, 0, 0.716275,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.782358,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.110522,-99) , 
20, 27.5573, 1, 0, 0.200156,-99) , 
18, 10.689, 0, 0, 0.510726,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.593247);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.326633,-99) , 
23, 1.27376, 0, 0, 0.621392,-99) , 
NN(
0, 
0, 
-1, 33.0846, 1, -1, 0.190801,-99) , 
49, 2.99925, 1, 0, 0.459482,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.787939);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.779648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330944,-99) , 
20, 24.2399, 0, 0, 0.710269,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.656466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0917557,-99) , 
16, 20.8128, 1, 0, 0.322622,-99) , 
19, 26.4321, 0, 0, 0.479065,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.514379);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.703874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327635,-99) , 
23, 2.49954, 0, 0, 0.627334,-99) , 
NN(
0, 
0, 
-1, 22.413, 1, -1, 0.294583,-99) , 
19, 25.0632, 0, 0, 0.433542,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.450856);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352177,-99) , 
12, 13.0802, 0, 0, 0.524765,-99) , 
NN(
0, 
0, 
-1, 31.4453, 0, -1, 0.0787143,-99) , 
13, 33.3086, 1, 0, 0.472304,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.413264);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428326,-99) , 
22, 13.8609, 0, 0, 0.533355,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.749404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0327143,-99) , 
19, 36.0149, 0, 0, 0.121801,-99) , 
13, 31.77, 1, 0, 0.469568,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.403326);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449951,-99) , 
21, 39.7379, 1, 0, 0.557222,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.700903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0248873,-99) , 
51, 33.8787, 0, 0, 0.19328,-99) , 
13, 30.1405, 1, 0, 0.49344,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.359222);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440833,-99) , 
14, 35.0918, 1, 0, 0.556027,-99) , 
NN(
0, 
0, 
-1, -0.758203, 0, -1, 0.16193,-99) , 
18, 5.41144, 0, 0, 0.492955,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.465098);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664418,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.109997,-99) , 
23, 1.24184, 0, 0, 0.625094,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0195577,-99) , 
21, 40.2748, 1, 0, 0.361203,-99) , 
50, 0.383654, 0, 0, 0.5215,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.358339);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.730479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456793,-99) , 
23, 12.6718, 0, 0, 0.53266,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.109282,-99) , 
19, 37.3739, 0, 0, 0.210073,-99) , 
20, 40.8337, 1, 0, 0.453773,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.352175);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600515,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402076,-99) , 
16, 24.1194, 1, 0, 0.525054,-99) , 
NN(
0, 
0, 
-1, 22.3237, 0, -1, 0.214749,-99) , 
20, 40.8334, 1, 0, 0.452979,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.302667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.311456,-99) , 
22, 1.27574, 0, 0, 0.497855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.670945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0744196,-99) , 
44, 0.165692, 0, 0, 0.194109,-99) , 
18, 5.38671, 0, 0, 0.445579,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.251537);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.217444,-99) , 
5, -1.23931, 0, 0, 0.494511,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.095556,-99) , 
19, 33.2682, 0, 0, 0.235036,-99) , 
20, 40.8335, 1, 0, 0.440365,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.363694);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.841167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457693,-99) , 
18, 22.2175, 1, 0, 0.660576,-99) , 
NN(
0, 
0, 
-1, 22.9449, 0, -1, 0.361144,-99) , 
43, 0.00492838, 0, 0, 0.40106,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.338805);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383017,-99) , 
22, 2.49683, 0, 0, 0.535476,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.160569,-99) , 
23, 6.29326, 1, 0, 0.242979,-99) , 
20, 40.8338, 1, 0, 0.471242,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.325901);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.749122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495196,-99) , 
19, 48.2088, 0, 0, 0.525655,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.65236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.157964,-99) , 
20, 19.2621, 1, 0, 0.306063,-99) , 
19, 19.5856, 0, 0, 0.439571,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.322067);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.689143, 1, 1, 0.575704,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0805901,-99) , 
13, 17.827, 1, 0, 0.340317,-99) , 
19, 18.2166, 0, 0, 0.499624,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.30273);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.737122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47604,-99) , 
23, 19.0523, 0, 0, 0.528226,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.121162,-99) , 
27, 19.1891, 1, 0, 0.282812,-99) , 
19, 16.8468, 0, 0, 0.453329,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.262121);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 21.1568, 1, 1, 0.588867,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.18828,-99) , 
14, 31.4559, 1, 0, 0.378395,-99) , 
12, 16.3507, 0, 0, 0.495905,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.219667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.683856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463775,-99) , 
46, -2.33079, 1, 0, 0.500694,-99) , 
NN(
0, 
0, 
-1, 22.4742, 1, -1, 0.320066,-99) , 
19, 16.8468, 0, 0, 0.455852,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.204768);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.85004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498235,-99) , 
51, 32.1441, 1, 0, 0.68259,-99) , 
NN(
0, 
0, 
-1, 5.4822, 0, -1, 0.432542,-99) , 
43, 0.00482213, 0, 0, 0.469024,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.231778);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 23.4383, 1, 1, 0.575796,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.145172,-99) , 
51, 32.3314, 0, 0, 0.343193,-99) , 
20, 39.1734, 1, 0, 0.521101,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.290522);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.174294,-99) , 
41, -0.806365, 0, 0, 0.549212,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.212118,-99) , 
20, 19.2621, 1, 0, 0.334435,-99) , 
19, 19.5859, 0, 0, 0.477051,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.126787);
  fForest.push_back( 
NN(
0, 
0, 
-1, -0.860641, 0, -1, 0.447368,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.188951);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.846914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415862,-99) , 
51, 36.5611, 1, 0, 0.703076,-99) , 
NN(
0, 
0, 
-1, 36.046, 1, -1, 0.44027,-99) , 
43, 0.00964427, 0, 0, 0.46445,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.172975);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450858,-99) , 
22, 13.0149, 0, 0, 0.505437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00473029,-99) , 
13, 36.2752, 1, 0, 0.495062,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.23765);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.827583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.300628,-99) , 
49, 0.176661, 0, 0, 0.744824,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370997,-99) , 
50, 0.193027, 0, 0, 0.497321,-99) , 
51, 22.3149, 1, 0, 0.527745,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.166387);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.117971,-99) , 
13, 34.7415, 1, 0, 0.512007,-99) , 
NN(
0, 
0, 
-1, 2.50881, 0, -1, 0.256424,-99) , 
12, 8.20639, 0, 0, 0.474939,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.132422);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364206,-99) , 
22, 2.50417, 0, 0, 0.487801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0100046,-99) , 
13, 36.3855, 1, 0, 0.478613,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.253361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.793261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462955,-99) , 
18, 15.9828, 1, 0, 0.516853,-99) , 
NN(
0, 
0, 
-1, 32.8258, 1, -1, 0.376994,-99) , 
12, 21.2672, 0, 0, 0.437116,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.315934);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.211491,-99) , 
22, 1.91845, 0, 0, 0.577835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101002,-99) , 
41, 0.419355, 0, 0, 0.438313,-99) , 
21, 39.4552, 1, 0, 0.493145,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.273353);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43309,-99) , 
51, 24.6235, 1, 0, 0.473271,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0675777,-99) , 
39, -0.758203, 0, 0, 0.217297,-99) , 
18, 5.37289, 0, 0, 0.443997,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.199791);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392163,-99) , 
12, 11.4651, 0, 0, 0.51414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.192731,-99) , 
18, 3.67086, 0, 0, 0.492136,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.182158);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417943,-99) , 
21, 44.6783, 1, 0, 0.484314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.211078,-99) , 
18, 3.63518, 0, 0, 0.467985,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.182266);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 17.1099, 1, 1, 0.646902,-99) , 
NN(
0, 
0, 
-1, 7.20216, 0, -1, 0.437476,-99) , 
43, 0.00482213, 0, 0, 0.46935,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.220176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.757401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.166464,-99) , 
23, 3.78076, 0, 0, 0.716322,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389053,-99) , 
21, 41.7144, 1, 0, 0.462602,-99) , 
12, 42.6043, 0, 0, 0.482084,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.191363);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312824,-99) , 
5, -1.40452, 0, 0, 0.516642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.193216,-99) , 
29, 3.68983, 0, 0, 0.491471,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0937333);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511851,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36916,-99) , 
20, 44.1523, 1, 0, 0.489724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00904317,-99) , 
13, 36.2616, 1, 0, 0.480673,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.251644);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351486,-99) , 
23, 1.01408, 0, 0, 0.513986,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.226853,-99) , 
23, 6.34455, 1, 0, 0.320916,-99) , 
20, 40.8337, 1, 0, 0.474783,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.304646);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650797,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.230414,-99) , 
22, 3.59593, 0, 0, 0.53445,-99) , 
NN(
0, 
0, 
-1, 0.29034, 0, -1, 0.406767,-99) , 
21, 38.4613, 1, 0, 0.450596,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.21756);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 31.8647, 0, 1, 0.63235,-99) , 
NN(
0, 
0, 
-1, 31.6741, 1, -1, 0.418431,-99) , 
12, 37.6263, 0, 0, 0.452557,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.192133);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46723,-99) , 
39, -0.689145, 1, 0, 0.51728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.120861,-99) , 
13, 22.3346, 1, 0, 0.379131,-99) , 
19, 16.8468, 0, 0, 0.488626,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.140354);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296055,-99) , 
4, 0.886751, 1, 0, 0.494623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.901096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.180486,-99) , 
19, 34.6475, 0, 0, 0.235854,-99) , 
18, 5.41055, 0, 0, 0.468595,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.197577);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.720293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474495,-99) , 
45, -2.54659, 1, 0, 0.501483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.111952,-99) , 
45, -3.0958, 0, 0, 0.316256,-99) , 
45, -2.93888, 0, 0, 0.474702,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.321565);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372711,-99) , 
16, 17.0775, 0, 0, 0.56019,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347563,-99) , 
22, 15.6242, 0, 0, 0.435087,-99) , 
12, 21.2411, 0, 0, 0.49368,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.189429);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.699453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490546,-99) , 
45, 2.53345, 0, 0, 0.530288,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.248479,-99) , 
16, 15.8861, 1, 0, 0.382186,-99) , 
19, 19.5857, 0, 0, 0.486731,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.152083);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.73613, 0, 1, 0.550048,-99) , 
NN(
0, 
0, 
-1, -2.93879, 0, -1, 0.387775,-99) , 
19, 16.847, 0, 0, 0.516165,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.17515);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.306211,-99) , 
2, 1.78699, 1, 0, 0.518067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.128718,-99) , 
45, -3.09582, 0, 0, 0.305424,-99) , 
45, -2.9389, 0, 0, 0.486561,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0892428);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.925876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285332,-99) , 
27, 8.95141, 0, 0, 0.834477,-99) , 
NN(
0, 
0, 
-1, -0.8273, 0, -1, 0.47621,-99) , 
14, 12.8448, 1, 0, 0.489046,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.238868);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.236235,-99) , 
22, 1.84314, 0, 0, 0.545969,-99) , 
NN(
0, 
0, 
-1, -0.612902, 0, -1, 0.4328,-99) , 
21, 39.455, 1, 0, 0.476098,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.283784);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.741885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4232,-99) , 
22, 7.79925, 1, 0, 0.624675,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37872,-99) , 
22, 11.4898, 0, 0, 0.487711,-99) , 
23, 15.5655, 0, 0, 0.52565,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.163217);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.930661, 1, 1, 0.546264,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101181,-99) , 
39, -0.758075, 0, 0, 0.285548,-99) , 
18, 5.46358, 0, 0, 0.523003,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.143979);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405739,-99) , 
20, 39.1745, 1, 0, 0.49165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.117823,-99) , 
20, 24.2544, 1, 0, 0.288873,-99) , 
40, -0.806445, 0, 0, 0.471639,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.229628);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5087,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343666,-99) , 
36, 0.733144, 1, 0, 0.474831,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.74326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.150926,-99) , 
19, 41.494, 0, 0, 0.301133,-99) , 
13, 28.6931, 1, 0, 0.440778,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.199941);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.841944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440779,-99) , 
39, -0.930919, 1, 0, 0.450909,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.61214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.187485,-99) , 
22, 20.8473, 0, 0, 0.249687,-99) , 
12, 6.55104, 0, 0, 0.435886,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.176991);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 24.2491, 1, 1, 0.678039,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.775415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440015,-99) , 
14, 13.2894, 1, 0, 0.449287,-99) , 
22, 25.1558, 0, 0, 0.464133,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.21741);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437384,-99) , 
6, 1.57019, 1, 0, 0.543447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.138186,-99) , 
39, -0.792748, 0, 0, 0.391206,-99) , 
18, 7.25544, 0, 0, 0.523903,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.253762);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.686897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42241,-99) , 
22, 7.28403, 1, 0, 0.549277,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0501439,-99) , 
22, 2.53088, 0, 0, 0.437825,-99) , 
20, 34.1962, 0, 0, 0.491454,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.110984);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 50.8957, 0, 1, 0.61113,-99) , 
NN(
0, 
0, 
-1, 29.9818, 1, -1, 0.464579,-99) , 
23, 20.3616, 0, 0, 0.485274,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.110013);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.828845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0785053,-99) , 
23, 6.92163, 0, 0, 0.692442,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367908,-99) , 
19, 16.8473, 0, 0, 0.474519,-99) , 
21, 23.2118, 1, 0, 0.486715,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.150805);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.668015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0495981,-99) , 
51, 40.8623, 1, 0, 0.623088,-99) , 
NN(
0, 
0, 
-1, 3.64287, 0, -1, 0.458403,-99) , 
19, 46.9722, 0, 0, 0.481838,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0833215);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 21.1574, 1, 1, 0.513929,-99) , 
NN(
0, 
0, 
-1, -2.73616, 0, -1, 0.369831,-99) , 
30, 2.12815, 1, 0, 0.488227,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.211818);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320796,-99) , 
22, 1.98198, 0, 0, 0.53265,-99) , 
NN(
0, 
0, 
-1, 2.51936, 1, -1, 0.426383,-99) , 
21, 42.7039, 1, 0, 0.474671,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0673638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.736156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329974,-99) , 
35, 2.24654, 1, 0, 0.687817,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.820688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492968,-99) , 
14, 12.0809, 1, 0, 0.500115,-99) , 
51, 48.8885, 0, 0, 0.512517,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.194303);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.645658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476237,-99) , 
20, 35.4809, 0, 0, 0.524248,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648999,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344817,-99) , 
21, 29.1355, 1, 0, 0.40352,-99) , 
20, 39.1745, 1, 0, 0.496549,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.198695);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313503,-99) , 
22, 1.91845, 0, 0, 0.569396,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.23815,-99) , 
50, 1.71537, 0, 0, 0.462198,-99) , 
21, 39.4549, 1, 0, 0.500548,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0814574);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.64616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483272,-99) , 
14, 19.8741, 1, 0, 0.496053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0783332,-99) , 
49, 0.182271, 0, 0, 0.249226,-99) , 
44, 0.0259967, 0, 0, 0.489611,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0873383);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 9.54812, 1, 1, 0.516751,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.80627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.110092,-99) , 
12, 17.2357, 0, 0, 0.248421,-99) , 
47, -2.93885, 0, 0, 0.502018,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.115495);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 31.9397, 0, 1, 0.884835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472955,-99) , 
51, 45.4621, 0, 0, 0.497249,-99) , 
20, 2.6685, 1, 0, 0.504695,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.18619);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 23.2118, 1, 1, 0.562642,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.662664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39846,-99) , 
22, 20.1755, 0, 0, 0.442988,-99) , 
5, -0.578475, 0, 0, 0.527815,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.110895);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322168,-99) , 
41, -0.806431, 0, 0, 0.497797,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0624588,-99) , 
12, 21.5927, 0, 0, 0.29816,-99) , 
46, 2.93889, 1, 0, 0.483553,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.140332);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.708989,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.141821,-99) , 
22, 11.8474, 1, 0, 0.614602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40297,-99) , 
14, 36.1619, 1, 0, 0.470776,-99) , 
16, 34.065, 0, 0, 0.48433,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0759836);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.840799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482409,-99) , 
14, 12.1408, 1, 0, 0.488129,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0123677,-99) , 
22, 7.65156, 0, 0, 0.264299,-99) , 
27, 5.96008, 0, 0, 0.479653,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0612064);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 20.9199, 0, 1, 0.861528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322829,-99) , 
20, 47.4716, 1, 0, 0.484184,-99) , 
14, 11.2003, 1, 0, 0.490684,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.137543);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.612897, 0, -1, 0.457519,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.186708,-99) , 
1, -0.519149, 1, 0, 0.284415,-99) , 
12, 6.60842, 0, 0, 0.446048,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0749599);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375904,-99) , 
5, 1.23721, 1, 0, 0.494126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0270407,-99) , 
13, 36.2752, 1, 0, 0.489542,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.166013);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386985,-99) , 
23, 2.358, 0, 0, 0.495455,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27188,-99) , 
20, 20.9271, 1, 0, 0.390352,-99) , 
19, 19.5859, 0, 0, 0.466657,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.124033);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.837852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49662,-99) , 
27, 24.6912, 0, 0, 0.73028,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445517,-99) , 
21, 38.1492, 1, 0, 0.474086,-99) , 
19, 51.0802, 0, 0, 0.480005,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.163907);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.108176,-99) , 
51, 39.4881, 1, 0, 0.624164,-99) , 
NN(
0, 
0, 
-1, 6.15187, 0, -1, 0.442033,-99) , 
19, 48.3412, 0, 0, 0.45639,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.130838);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451833,-99) , 
39, -0.410625, 1, 0, 0.502974,-99) , 
NN(
0, 
0, 
-1, -0.792351, 0, -1, 0.316281,-99) , 
18, 5.3601, 0, 0, 0.488256,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0856239);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496099,-99) , 
18, 40.7408, 0, 0, 0.512952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.236534,-99) , 
41, -0.612884, 1, 0, 0.313623,-99) , 
12, 6.55104, 0, 0, 0.497958,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.100904);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0179602,-99) , 
13, 36.178, 1, 0, 0.516589,-99) , 
NN(
0, 
0, 
-1, 9.1027, 0, -1, 0.360188,-99) , 
0, -1.54962, 0, 0, 0.493082,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0219628);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499329,-99) , 
18, 48.4887, 0, 0, 0.504506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0329252,-99) , 
13, 36.2616, 1, 0, 0.501106,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0869427);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375932,-99) , 
1, -1.51775, 0, 0, 0.504616,-99) , 
NN(
0, 
0, 
-1, -0.612884, 1, -1, 0.203025,-99) , 
12, 4.88004, 0, 0, 0.495296,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.10657);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.807413,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.30541,-99) , 
23, 2.35583, 0, 0, 0.682929,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353525,-99) , 
39, -0.791984, 0, 0, 0.485573,-99) , 
14, 16.545, 1, 0, 0.495732,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0431448);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 36.2752, 1, -1, 0.495674,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.729782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.263489,-99) , 
5, 2.23009, 0, 0, 0.31975,-99) , 
12, 6.54624, 0, 0, 0.4853,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0709055);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.882094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444224,-99) , 
27, 14.3307, 0, 0, 0.685839,-99) , 
NN(
0, 
0, 
-1, 44.1527, 1, -1, 0.481829,-99) , 
14, 16.62, 1, 0, 0.492456,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.1952);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48476,-99) , 
23, 10.4741, 0, 0, 0.53499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341575,-99) , 
23, 3.87177, 1, 0, 0.403345,-99) , 
20, 39.1742, 1, 0, 0.504076,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0556913);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 8.11065, 1, 1, 0.826408,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.794934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485495,-99) , 
29, 48.4886, 0, 0, 0.490297,-99) , 
14, 11.6611, 1, 0, 0.495031,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0669343);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.748408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394261,-99) , 
21, 36.0719, 0, 0, 0.669779,-99) , 
NN(
0, 
0, 
-1, -0.136532, 1, -1, 0.485629,-99) , 
51, 48.934, 0, 0, 0.497905,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.12474);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379006,-99) , 
20, 47.4714, 1, 0, 0.524106,-99) , 
NN(
0, 
0, 
-1, 34.0691, 0, -1, 0.137053,-99) , 
42, 0.401844, 1, 0, 0.517653,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0497088);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.288748,-99) , 
12, 4.92539, 0, 0, 0.503425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0432563,-99) , 
13, 36.178, 1, 0, 0.499727,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.122292);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48675,-99) , 
14, 28.5965, 1, 0, 0.517914,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.142661,-99) , 
28, 30.5197, 0, 0, 0.311717,-99) , 
44, 0.0483063, 0, 0, 0.503226,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.179356);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.758628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474384,-99) , 
23, 4.98874, 1, 0, 0.570415,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385031,-99) , 
44, 0.155973, 0, 0, 0.471511,-99) , 
22, 16.9272, 0, 0, 0.499661,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0544243);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -2.93881, 1, 1, 0.510973,-99) , 
NN(
0, 
0, 
-1, -2.93876, 0, -1, 0.379238,-99) , 
12, 8.20277, 0, 0, 0.496949,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.163021);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342485,-99) , 
20, 30.8854, 1, 0, 0.570007,-99) , 
NN(
0, 
0, 
-1, 2.57187, 0, -1, 0.469338,-99) , 
22, 18.2315, 0, 0, 0.494811,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.330404);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0581078,-99) , 
22, 5.03727, 0, 0, 0.569407,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39517,-99) , 
22, 8.68592, 1, 0, 0.476815,-99) , 
20, 27.5596, 1, 0, 0.508651,-99)    );
   return;
};

// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
