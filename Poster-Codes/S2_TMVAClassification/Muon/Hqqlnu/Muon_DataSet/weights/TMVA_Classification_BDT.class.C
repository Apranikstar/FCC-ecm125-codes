// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.32/00       [401408]
Creator        : apranikstar
Date           : Mon Dec  9 19:16:25 2024
Host           : Darwin ChristoersMBP72.localdomain 23.5.0 Darwin Kernel Version 23.5.0: Wed May 1 20:12:58 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6000 arm64
Dir            : /Users/apranikstar/Desktop/FCC_Presentation/TMVAClassification/Muon/Hqqlnu
Training events: 360658
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "2" [Max depth of the decision tree allowed]
MinNodeSize: "0.5" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "6.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "7" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 52
Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       F                                 'F'    [-5.20369148254,5.2392334938]
Delta_rapidity_Muon_JNLO      Delta_rapidity_Muon_JNLO      Delta_rapidity_Muon_JNLO      Delta_rapidity_Muon_JNLO      F                                 'F'    [-5.13071346283,5.2392334938]
Delta_rapidity_Muon_JLO       Delta_rapidity_Muon_JLO       Delta_rapidity_Muon_JLO       Delta_rapidity_Muon_JLO       F                                 'F'    [-5.1524515152,5.20369148254]
JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               F                                 'F'    [-2.99947595596,2.99897766113]
JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                F                                 'F'    [-2.93780231476,2.94795370102]
Muon_Rapidity                 Muon_Rapidity                 Muon_Rapidity                 Muon_Rapidity                 F                                 'F'    [-2.56040263176,2.55979657173]
Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            F                                 'F'    [-6.36412143707,5.79493188858]
Delta_eta_Muon_NJO            Delta_eta_Muon_NJO            Delta_eta_Muon_NJO            Delta_eta_Muon_NJO            F                                 'F'    [-5.7471280098,6.00082159042]
Delta_eta_Muon_JLO            Delta_eta_Muon_JLO            Delta_eta_Muon_JLO            Delta_eta_Muon_JLO            F                                 'F'    [-5.1535525322,5.20887231827]
JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    F                                 'F'    [-4.23229408264,4.24270248413]
JetLO_eta                     JetLO_eta                     JetLO_eta                     JetLO_eta                     F                                 'F'    [-3.94285011292,4.29151439667]
Muon_eta                      Muon_eta                      Muon_eta                      Muon_eta                      F                                 'F'    [-2.56076645851,2.55991125107]
PT_Muon                       PT_Muon                       PT_Muon                       PT_Muon                       F                                 'F'    [1.62937152386,52.4251251221]
PT_JNLO                       PT_JNLO                       PT_JNLO                       PT_JNLO                       F                                 'F'    [1.00019741058,50.7330207825]
PT_JLO                        PT_JLO                        PT_JLO                        PT_JLO                        F                                 'F'    [1.11171507835,52.4370269775]
Energy_Transverse_Muon        Energy_Transverse_Muon        Energy_Transverse_Muon        Energy_Transverse_Muon        F                                 'F'    [1.6294580698,52.4252319336]
Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        F                                 'F'    [1.00019741058,52.3960151672]
Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         F                                 'F'    [1.16714024544,52.448589325]
Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         F                                 'F'    [0.0571668893099,55.1250839233]
Energy_Muon                   Energy_Muon                   Energy_Muon                   Energy_Muon                   F                                 'F'    [10.0000734329,52.4498558044]
Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   F                                 'F'    [1.00430083275,52.4499130249]
Energy_JLO                    Energy_JLO                    Energy_JLO                    Energy_JLO                    F                                 'F'    [2.43145012856,52.4499588013]
M_JLO                         M_JLO                         M_JLO                         M_JLO                         F                                 'F'    [-0.0285523924977,40.0253715515]
M_JNLO                        M_JNLO                        M_JNLO                        M_JNLO                        F                                 'F'    [-0.0278403908014,41.4108963013]
M_Muon                        M_Muon                        M_Muon                        M_Muon                        F                                 'F'    [0.1020077914,0.109375342727]
M_met                         M_met                         M_met                         M_met                         F                                 'F'    [-0.0206943303347,0.0209629554302]
MT_Muon                       MT_Muon                       MT_Muon                       MT_Muon                       F                                 'F'    [1.63278603554,52.4252319336]
MT_JNLO                       MT_JNLO                       MT_JNLO                       MT_JNLO                       F                                 'F'    [1.00019824505,52.3992652893]
MT_JLO                        MT_JLO                        MT_JLO                        MT_JLO                        F                                 'F'    [2.4211139679,52.4486579895]
MT_met                        MT_met                        MT_met                        MT_met                        F                                 'F'    [0.0569661334157,55.1250839233]
Phi_Muon                      Phi_Muon                      Phi_Muon                      Phi_Muon                      F                                 'F'    [-3.1415886879,3.14158177376]
Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      F                                 'F'    [-3.14157366753,3.14159035683]
Phi_JLO                       Phi_JLO                       Phi_JLO                       Phi_JLO                       F                                 'F'    [-3.14155435562,3.14155340195]
Theta_Muon                    Theta_Muon                    Theta_Muon                    Theta_Muon                    F                                 'F'    [0.154316231608,2.98740792274]
Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    F                                 'F'    [0.0287354383618,3.11255669594]
Theta_JLO                     Theta_JLO                     Theta_JLO                     Theta_JLO                     F                                 'F'    [0.0273666642606,3.10281181335]
cosTheta_Muon                 cosTheta_Muon                 cosTheta_Muon                 cosTheta_Muon                 F                                 'F'    [-0.988137066364,0.98811686039]
cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 F                                 'F'    [-0.999578475952,0.99958717823]
cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  F                                 'F'    [-0.999248087406,0.999625563622]
CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             F                                 'F'    [-0.999996900558,0.0707348510623]
CosAngle_Muon_JNLO            CosAngle_Muon_JNLO            CosAngle_Muon_JNLO            CosAngle_Muon_JNLO            F                                 'F'    [-0.999996900558,1]
CosAngle_Muon_JLO             CosAngle_Muon_JLO             CosAngle_Muon_JLO             CosAngle_Muon_JLO             F                                 'F'    [-0.999973714352,1]
Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             F                                 'F'    [3.49547057965e-08,0.499178171158]
Aplanarity                    Aplanarity                    Aplanarity                    Aplanarity                    F                                 'F'    [-4.99600361081e-16,0.14452393353]
Sphericity                    Sphericity                    Sphericity                    Sphericity                    F                                 'F'    [5.24320569184e-08,0.783724009991]
DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             F                                 'F'    [-3.14157986641,3.14159083366]
DeltaPhi_Muon_JNLO            DeltaPhi_Muon_JNLO            DeltaPhi_Muon_JNLO            DeltaPhi_Muon_JNLO            F                                 'F'    [-3.14149618149,3.14158177376]
DeltaPhi_Muon_JLO             DeltaPhi_Muon_JLO             DeltaPhi_Muon_JLO             DeltaPhi_Muon_JLO             F                                 'F'    [-3.14157104492,3.14153409004]
DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               F                                 'F'    [1.50067317486,6.77363920212]
DeltaR_Muon_JLO               DeltaR_Muon_JLO               DeltaR_Muon_JLO               DeltaR_Muon_JLO               F                                 'F'    [0,5.63264894485]
DeltaR_Muon_JNLO              DeltaR_Muon_JNLO              DeltaR_Muon_JNLO              DeltaR_Muon_JNLO              F                                 'F'    [0,6.23727750778]
Energy_MET                    Energy_MET                    Energy_MET                    Energy_MET                    F                                 'F'    [20.0001049042,55.7696914673]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTNode

#ifndef BDTNode__def
#define BDTNode__def

class BDTNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 52 )
   {
      // the training input variables
      const char* inputVars[] = { "Delta_rapidity_JNLO_JLO", "Delta_rapidity_Muon_JNLO", "Delta_rapidity_Muon_JLO", "JetNLO_Rapidity", "JetLO_Rapidity", "Muon_Rapidity", "Delta_eta_JLO_JNLO", "Delta_eta_Muon_NJO", "Delta_eta_Muon_JLO", "JetNLO_eta", "JetLO_eta", "Muon_eta", "PT_Muon", "PT_JNLO", "PT_JLO", "Energy_Transverse_Muon", "Energy_Transverse_JNLO", "Energy_Transverse_JLO", "Energy_Transverse_met", "Energy_Muon", "Energy_JNLO", "Energy_JLO", "M_JLO", "M_JNLO", "M_Muon", "M_met", "MT_Muon", "MT_JNLO", "MT_JLO", "MT_met", "Phi_Muon", "Phi_JNLO", "Phi_JLO", "Theta_Muon", "Theta_JNLO", "Theta_JLO", "cosTheta_Muon", "cosTheta_JNLO", "cosTheta_JLO", "CosAngle_JNLO_JLO", "CosAngle_Muon_JNLO", "CosAngle_Muon_JLO", "Linear_Aplanarity", "Aplanarity", "Sphericity", "DeltaPhi_JNLO_JLO", "DeltaPhi_Muon_JNLO", "DeltaPhi_Muon_JLO", "DeltaR_JNLO_JLO", "DeltaR_Muon_JLO", "DeltaR_Muon_JNLO", "Energy_MET" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;
      fVmin[29] = 0;
      fVmax[29] = 0;
      fVmin[30] = 0;
      fVmax[30] = 0;
      fVmin[31] = 0;
      fVmax[31] = 0;
      fVmin[32] = 0;
      fVmax[32] = 0;
      fVmin[33] = 0;
      fVmax[33] = 0;
      fVmin[34] = 0;
      fVmax[34] = 0;
      fVmin[35] = 0;
      fVmax[35] = 0;
      fVmin[36] = 0;
      fVmax[36] = 0;
      fVmin[37] = 0;
      fVmax[37] = 0;
      fVmin[38] = 0;
      fVmax[38] = 0;
      fVmin[39] = 0;
      fVmax[39] = 0;
      fVmin[40] = 0;
      fVmax[40] = 0;
      fVmin[41] = 0;
      fVmax[41] = 0;
      fVmin[42] = 0;
      fVmax[42] = 0;
      fVmin[43] = 0;
      fVmax[43] = 0;
      fVmin[44] = 0;
      fVmax[44] = 0;
      fVmin[45] = 0;
      fVmax[45] = 0;
      fVmin[46] = 0;
      fVmax[46] = 0;
      fVmin[47] = 0;
      fVmax[47] = 0;
      fVmin[48] = 0;
      fVmax[48] = 0;
      fVmin[49] = 0;
      fVmax[49] = 0;
      fVmin[50] = 0;
      fVmax[50] = 0;
      fVmin[51] = 0;
      fVmax[51] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';
      fType[29] = 'F';
      fType[30] = 'F';
      fType[31] = 'F';
      fType[32] = 'F';
      fType[33] = 'F';
      fType[34] = 'F';
      fType[35] = 'F';
      fType[36] = 'F';
      fType[37] = 'F';
      fType[38] = 'F';
      fType[39] = 'F';
      fType[40] = 'F';
      fType[41] = 'F';
      fType[42] = 'F';
      fType[43] = 'F';
      fType[44] = 'F';
      fType[45] = 'F';
      fType[46] = 'F';
      fType[47] = 'F';
      fType[48] = 'F';
      fType[49] = 'F';
      fType[50] = 'F';
      fType[51] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[52];
   double fVmax[52];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[52];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.58779316977186);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.99345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34719,-99) , 
20, 37.5152, 0, 0, 0.911599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.74958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0604401,-99) , 
43, 0.00320426, 0, 0, 0.134434,-99) , 
18, 12.4919, 0, 0, 0.499307,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.30228);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.957728,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369324,-99) , 
50, 0.386964, 0, 0, 0.849867,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0849206,-99) , 
48, 3.1088, 1, 0, 0.14424,-99) , 
18, 8.94514, 0, 0, 0.548685,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.06602);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.948729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.197391,-99) , 
19, 23.6934, 1, 0, 0.913838,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631723,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0827997,-99) , 
40, 0.935486, 1, 0, 0.316456,-99) , 
18, 14.2672, 0, 0, 0.559906,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.691494);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.971766,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43669,-99) , 
20, 40.8331, 0, 0, 0.780551,-99) , 
NN(
0, 
0, 
-1, 0.186193, 0, -1, 0.295685,-99) , 
18, 10.7147, 0, 0, 0.517796,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.726579);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.900119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43476,-99) , 
20, 44.1527, 0, 0, 0.681436,-99) , 
NN(
0, 
0, 
-1, 0.871005, 1, -1, 0.161826,-99) , 
18, 5.38592, 0, 0, 0.530498,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.715578);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.842152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333319,-99) , 
49, 0.167982, 0, 0, 0.782154,-99) , 
NN(
0, 
0, 
-1, 0.191876, 0, -1, 0.32096,-99) , 
18, 7.10801, 0, 0, 0.606479,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.833207);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.804435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335683,-99) , 
41, 0.935494, 1, 0, 0.674302,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.939104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.116957,-99) , 
48, 3.05712, 1, 0, 0.217779,-99) , 
50, 0.189172, 0, 0, 0.54641,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.688896);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.817158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428208,-99) , 
41, -0.741913, 0, 0, 0.697255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.156403,-99) , 
18, 3.63459, 0, 0, 0.603706,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.620443);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 42.4968, 0, 1, 0.754316,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.71153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277203,-99) , 
14, 29.8862, 1, 0, 0.433782,-99) , 
21, 47.6095, 0, 0, 0.604667,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.563864);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.845929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00964118,-99) , 
19, 26.4321, 1, 0, 0.798775,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.29085,-99) , 
20, 45.8118, 0, 0, 0.442981,-99) , 
18, 19.4374, 0, 0, 0.533417,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.752933);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.741063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.243206,-99) , 
49, 0.157829, 0, 0, 0.649392,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.880447,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.131652,-99) , 
48, 3.06702, 1, 0, 0.28503,-99) , 
50, 0.201202, 0, 0, 0.551212,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.552727);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.867986,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242616,-99) , 
50, 0.15007, 0, 0, 0.772941,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.679136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329633,-99) , 
18, 17.5337, 0, 0, 0.438071,-99) , 
17, 45.8241, 0, 0, 0.517425,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.28909);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.89829, 1, 1, 0.590907,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.174197,-99) , 
17, 30.7545, 1, 0, 0.337713,-99) , 
21, 42.871, 0, 0, 0.526707,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.37657);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.65176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421362,-99) , 
20, 44.1535, 0, 0, 0.539987,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0899849,-99) , 
18, 12.072, 0, 0, 0.240149,-99) , 
21, 43.1007, 0, 0, 0.473919,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.398913);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.708801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0437709,-99) , 
20, 29.22, 0, 0, 0.675956,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.247761,-99) , 
18, 8.79249, 0, 0, 0.399461,-99) , 
28, 46.0306, 0, 0, 0.475038,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.254469);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.906535, 0, 1, 0.564468,-99) , 
NN(
0, 
0, 
-1, 5.16573, 0, -1, 0.288608,-99) , 
21, 44.3825, 0, 0, 0.489365,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.407801);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.69286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453396,-99) , 
18, 12.3391, 1, 0, 0.593788,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.321341,-99) , 
4, 0.85946, 0, 0, 0.371415,-99) , 
7, -0.0596059, 1, 0, 0.465231,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.307613);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409412,-99) , 
28, 42.8351, 0, 0, 0.496059,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.163331,-99) , 
41, -0.746858, 0, 0, 0.238352,-99) , 
47, 2.93883, 1, 0, 0.45814,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.276792);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261527,-99) , 
47, 2.93882, 1, 0, 0.540201,-99) , 
NN(
0, 
0, 
-1, 0.935502, 1, -1, 0.314678,-99) , 
18, 5.35311, 0, 0, 0.489646,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.240548);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.91541, 0, 1, 0.74531,-99) , 
NN(
0, 
0, 
-1, 38.4445, 0, -1, 0.42116,-99) , 
28, 49.2396, 0, 0, 0.460234,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.336382);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.714712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484568,-99) , 
21, 47.6712, 1, 0, 0.595067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.310659,-99) , 
42, 0.112452, 0, 0, 0.380362,-99) , 
22, 12.6487, 0, 0, 0.504827,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.373851);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.119069,-99) , 
22, 5.03146, 0, 0, 0.582664,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.80159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.241457,-99) , 
45, -3.05007, 0, 0, 0.341013,-99) , 
45, -2.93889, 0, 0, 0.525332,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.342585);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.075772,-99) , 
19, 30.5401, 1, 0, 0.524314,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.756629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.144846,-99) , 
45, 3.04355, 1, 0, 0.285178,-99) , 
45, 2.9389, 1, 0, 0.45747,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.234781);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.858832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495424,-99) , 
44, 0.139949, 1, 0, 0.657916,-99) , 
NN(
0, 
0, 
-1, 3.58085, 0, -1, 0.415011,-99) , 
22, 25.8127, 0, 0, 0.451165,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.205405);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465076,-99) , 
27, 39.135, 0, 0, 0.516983,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.309162,-99) , 
18, 3.61776, 0, 0, 0.487446,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.324164);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.680147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0303892,-99) , 
21, 36.8879, 0, 0, 0.636102,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396437,-99) , 
39, -0.861818, 1, 0, 0.462042,-99) , 
2, -0.475484, 1, 0, 0.512044,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0991311);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.303076, 1, 1, 0.792418,-99) , 
NN(
0, 
0, 
-1, -2.93889, 0, -1, 0.473872,-99) , 
17, 50.7895, 0, 0, 0.491914,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.306208);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.660367,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.280575,-99) , 
34, 2.51065, 1, 0, 0.617035,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331595,-99) , 
34, 1.72146, 1, 0, 0.454161,-99) , 
31, 0.506715, 0, 0, 0.523333,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.169463);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.121816,-99) , 
22, 2.50673, 0, 0, 0.524662,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.784965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.217857,-99) , 
13, 18.4065, 1, 0, 0.274134,-99) , 
47, -2.93876, 0, 0, 0.498784,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.276863);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0657843,-99) , 
51, 39.6157, 1, 0, 0.510848,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.740255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.191427,-99) , 
45, 3.06969, 1, 0, 0.350949,-99) , 
45, 2.93891, 1, 0, 0.465702,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.310624);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398053,-99) , 
50, 2.35258, 0, 0, 0.457665,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.832625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0971626,-99) , 
40, -0.619123, 0, 0, 0.193752,-99) , 
46, 2.9389, 1, 0, 0.426094,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.218679);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454477,-99) , 
35, 2.17675, 0, 0, 0.486795,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.208081,-99) , 
37, -0.354607, 1, 0, 0.316652,-99) , 
32, 2.12815, 1, 0, 0.4585,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.11948);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.987399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362438,-99) , 
18, 17.5774, 1, 0, 0.872421,-99) , 
NN(
0, 
0, 
-1, 31.5387, 1, -1, 0.467021,-99) , 
42, 0.273097, 0, 0, 0.484315,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.319513);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.785897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375385,-99) , 
18, 14.2797, 1, 0, 0.624025,-99) , 
NN(
0, 
0, 
-1, 10.7371, 0, -1, 0.400424,-99) , 
27, 42.4511, 0, 0, 0.455986,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.220956);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00855864,-99) , 
19, 33.2788, 1, 0, 0.546326,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.148404,-99) , 
8, -0.74248, 1, 0, 0.253469,-99) , 
47, 2.93883, 1, 0, 0.514427,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.209361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.726716,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496633,-99) , 
14, 32.6372, 1, 0, 0.604163,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.210272,-99) , 
48, 3.4203, 1, 0, 0.45315,-99) , 
20, 45.8109, 1, 0, 0.525202,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.228692);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.128396,-99) , 
21, 40.078, 0, 0, 0.710224,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.257142,-99) , 
51, 30.3148, 1, 0, 0.476294,-99) , 
47, 2.12812, 0, 0, 0.53606,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.371698);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630728,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33349,-99) , 
45, 2.93891, 1, 0, 0.559687,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.73352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353001,-99) , 
46, -2.73614, 1, 0, 0.400376,-99) , 
20, 44.1516, 1, 0, 0.466428,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0631956);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.916637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497529,-99) , 
26, 24.9231, 0, 0, 0.510394,-99) , 
NN(
0, 
0, 
-1, -2.53348, 1, -1, 0.009079,-99) , 
19, 30.5401, 1, 0, 0.498674,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.264276);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434747,-99) , 
18, 13.5878, 1, 0, 0.514672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224953,-99) , 
18, 3.61802, 0, 0, 0.483068,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.235619);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47339,-99) , 
17, 42.7071, 0, 0, 0.537458,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.807582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.118323,-99) , 
48, 3.09292, 1, 0, 0.297098,-99) , 
47, -2.93879, 0, 0, 0.512686,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.319467);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.6462,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.145859,-99) , 
21, 38.4257, 0, 0, 0.617907,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341786,-99) , 
2, 0.214057, 0, 0, 0.448802,-99) , 
2, -0.288109, 1, 0, 0.501043,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.108041);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.721888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47958,-99) , 
27, 17.5866, 1, 0, 0.498049,-99) , 
NN(
0, 
0, 
-1, 20.5426, 0, -1, 0.11782,-99) , 
44, 0.0241546, 0, 0, 0.48804,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.240622);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438961,-99) , 
20, 45.8141, 1, 0, 0.628105,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345187,-99) , 
18, 10.5682, 0, 0, 0.454491,-99) , 
21, 50.8938, 0, 0, 0.496437,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0783241);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 12.5393, 1, 1, 0.844844,-99) , 
NN(
0, 
0, 
-1, 32.6927, 1, -1, 0.476905,-99) , 
42, 0.273098, 0, 0, 0.487763,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.236716);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477624,-99) , 
19, 16.8475, 0, 0, 0.546226,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346015,-99) , 
12, 9.82008, 1, 0, 0.406585,-99) , 
51, 26.8694, 1, 0, 0.489707,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.187015);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.758209, 0, 1, 0.585717,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506552,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323042,-99) , 
23, 11.4332, 0, 0, 0.441561,-99) , 
25, -0.00273021, 0, 0, 0.521211,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.170912);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.70369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484826,-99) , 
30, 1.96475, 1, 0, 0.587048,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373402,-99) , 
51, 26.9234, 1, 0, 0.454661,-99) , 
30, 1.31744, 0, 0, 0.494676,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.235369);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.977638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.328642,-99) , 
18, 19.3426, 1, 0, 0.876335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405566,-99) , 
27, 40.7728, 0, 0, 0.451466,-99) , 
42, 0.273743, 0, 0, 0.46552,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.171256);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0454273,-99) , 
51, 38.3186, 1, 0, 0.648882,-99) , 
NN(
0, 
0, 
-1, 0.193482, 0, -1, 0.460805,-99) , 
34, 2.21725, 0, 0, 0.505752,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.218742);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.714444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489253,-99) , 
20, 45.8088, 1, 0, 0.607836,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.201351,-99) , 
29, 5.37859, 0, 0, 0.454404,-99) , 
31, 0.506715, 0, 0, 0.522902,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.20956);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323905,-99) , 
18, 3.77265, 0, 0, 0.528592,-99) , 
NN(
0, 
0, 
-1, 29.2162, 1, -1, 0.0226044,-99) , 
51, 38.4618, 1, 0, 0.516656,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.237066);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598106,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437638,-99) , 
44, 0.140065, 1, 0, 0.520437,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.16673,-99) , 
44, 0.144923, 0, 0, 0.368268,-99) , 
21, 44.4674, 0, 0, 0.484037,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.214138);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
22, 1.25251, 0, 0, 0.545171,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38627,-99) , 
22, 27.1051, 0, 0, 0.412682,-99) , 
25, -0.00322515, 0, 0, 0.486734,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0838729);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.984645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.228604,-99) , 
18, 14.2649, 1, 0, 0.860692,-99) , 
NN(
0, 
0, 
-1, 30.5403, 1, -1, 0.480312,-99) , 
42, 0.273416, 0, 0, 0.49376,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.221577);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.976389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356562,-99) , 
18, 19.4622, 1, 0, 0.889566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416029,-99) , 
13, 30.7156, 0, 0, 0.497499,-99) , 
42, 0.273743, 0, 0, 0.511164,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.251585);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433002,-99) , 
20, 45.8118, 1, 0, 0.508687,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.768051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.12769,-99) , 
47, -3.01089, 0, 0, 0.261018,-99) , 
47, -2.93879, 0, 0, 0.486696,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.205518);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.715835,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485346,-99) , 
49, 2.36208, 0, 0, 0.585914,-99) , 
NN(
0, 
0, 
-1, 0.165052, 0, -1, 0.430606,-99) , 
14, 37.5159, 1, 0, 0.503047,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.213912);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.934968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0710432,-99) , 
18, 17.5856, 1, 0, 0.809821,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323234,-99) , 
21, 41.1555, 0, 0, 0.518262,-99) , 
26, 24.5729, 0, 0, 0.53939,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.120742);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 34.6481, 1, 0, 0.505922,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759228,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.169533,-99) , 
29, 17.7267, 0, 0, 0.296599,-99) , 
47, -2.93889, 0, 0, 0.484217,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.178487);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.21988, 0, 1, 0.569548,-99) , 
NN(
0, 
0, 
-1, -1.92543, 0, -1, 0.423019,-99) , 
32, -0.506698, 1, 0, 0.485213,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.161945);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.78203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.21959,-99) , 
18, 26.7074, 1, 0, 0.681724,-99) , 
NN(
0, 
0, 
-1, 30.8761, 0, -1, 0.460716,-99) , 
42, 0.14475, 0, 0, 0.486045,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.200365);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368164,-99) , 
49, 0.17825, 0, 0, 0.52498,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.80388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.229078,-99) , 
18, 18.0125, 0, 0, 0.319462,-99) , 
47, -2.93879, 0, 0, 0.505378,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.228293);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.934166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.195214,-99) , 
18, 14.4867, 1, 0, 0.763789,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422042,-99) , 
27, 20.8929, 1, 0, 0.445233,-99) , 
26, 26.2098, 0, 0, 0.457905,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.120209);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390122,-99) , 
15, 16.3008, 1, 0, 0.505782,-99) , 
NN(
0, 
0, 
-1, 1.22278, 0, -1, 0.0590738,-99) , 
22, 2.55652, 0, 0, 0.497038,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.136187);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464622,-99) , 
25, -0.00657501, 1, 0, 0.491258,-99) , 
NN(
0, 
0, 
-1, 1.23182, 0, -1, 0.0353384,-99) , 
23, 1.27715, 0, 0, 0.483497,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0925809);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.947709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375034,-99) , 
18, 21.1436, 1, 0, 0.839553,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327686,-99) , 
19, 19.5854, 1, 0, 0.478742,-99) , 
42, 0.273097, 0, 0, 0.489163,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0895677);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.125441,-99) , 
29, 30.2556, 1, 0, 0.499889,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.185533,-99) , 
8, 0.622999, 0, 0, 0.300923,-99) , 
47, 2.93883, 1, 0, 0.482427,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.163408);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.53347, 0, 1, 0.607247,-99) , 
NN(
0, 
0, 
-1, 1.92491, 1, -1, 0.462586,-99) , 
45, 2.33086, 0, 0, 0.52526,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.074607);
  fForest.push_back( 
NN(
0, 
0, 
-1, 2.5024, 0, -1, 0.468954,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0909392);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.699224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48395,-99) , 
17, 24.8406, 1, 0, 0.502085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
22, 1.26351, 0, 0, 0.495292,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0820857);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.04095, 0, 1, 0.527758,-99) , 
NN(
0, 
0, 
-1, 30.874, 0, -1, 0.046153,-99) , 
22, 2.55557, 0, 0, 0.520533,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.245396);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.260871,-99) , 
19, 20.9553, 1, 0, 0.548959,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372127,-99) , 
30, -1.52013, 1, 0, 0.430646,-99) , 
31, -0.10133, 0, 0, 0.489055,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.184887);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.182793,-99) , 
39, -0.620055, 1, 0, 0.521546,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.23175,-99) , 
17, 38.4079, 1, 0, 0.33746,-99) , 
50, 0.196048, 0, 0, 0.490437,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.10223);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.884152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.116197,-99) , 
19, 31.788, 1, 0, 0.756645,-99) , 
NN(
0, 
0, 
-1, 26.431, 1, -1, 0.474711,-99) , 
26, 24.5955, 0, 0, 0.488229,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.20004);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429242,-99) , 
7, -0.48879, 1, 0, 0.466971,-99) , 
NN(
0, 
0, 
-1, 16.0135, 0, -1, 0.178448,-99) , 
40, -0.935481, 0, 0, 0.454984,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.183417);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398475,-99) , 
3, 0.676996, 1, 0, 0.505015,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.902568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.234945,-99) , 
41, -0.633733, 0, 0, 0.302265,-99) , 
47, 2.93872, 1, 0, 0.487915,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.105585);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485059,-99) , 
30, 1.72255, 0, 0, 0.515344,-99) , 
NN(
0, 
0, 
-1, 2.49328, 0, -1, 0.0875683,-99) , 
23, 1.27453, 0, 0, 0.508304,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.165618);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101326,-99) , 
20, 29.2137, 0, 0, 0.637759,-99) , 
NN(
0, 
0, 
-1, -2.12809, 0, -1, 0.460628,-99) , 
49, 0.174204, 1, 0, 0.485425,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.181307);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.947526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322201,-99) , 
14, 35.9137, 1, 0, 0.844015,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382463,-99) , 
50, 0.196048, 0, 0, 0.519807,-99) , 
26, 26.2061, 0, 0, 0.536864,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.169797);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 26.1953, 0, 1, 0.548887,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395305,-99) , 
7, 0.159041, 0, 0, 0.434659,-99) , 
5, -0.248055, 0, 0, 0.507605,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.128324);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458105,-99) , 
22, 12.8921, 0, 0, 0.513618,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 33.2781, 1, 0, 0.508042,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.196964);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427685,-99) , 
49, 2.54378, 0, 0, 0.47858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312483,-99) , 
18, 3.61802, 0, 0, 0.461931,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.13494);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.001786,-99) , 
18, 31.8584, 1, 0, 0.535715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368596,-99) , 
18, 3.60967, 0, 0, 0.517817,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.140751);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.942619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397465,-99) , 
18, 19.1891, 1, 0, 0.776208,-99) , 
NN(
0, 
0, 
-1, 10.6684, 0, -1, 0.448654,-99) , 
42, 0.257332, 0, 0, 0.456669,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0791063);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521162,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.170387,-99) , 
44, 0.0252937, 0, 0, 0.514829,-99) , 
NN(
0, 
0, 
-1, 1.11474, 0, -1, 0.0790357,-99) , 
23, 1.24974, 0, 0, 0.507995,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.178125);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 40.5882, 0, 1, 0.541166,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3781,-99) , 
9, -0.796177, 1, 0, 0.428846,-99) , 
35, 1.82382, 0, 0, 0.468243,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0948411);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.909414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272571,-99) , 
18, 14.2383, 1, 0, 0.755135,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.22449,-99) , 
39, -0.620054, 1, 0, 0.502727,-99) , 
26, 24.5647, 0, 0, 0.512645,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.120928);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400449,-99) , 
43, 0.00451844, 1, 0, 0.470284,-99) , 
NN(
0, 
0, 
-1, -0.0824697, 1, -1, 0.0932774,-99) , 
22, 2.52926, 0, 0, 0.462944,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.121025);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448624,-99) , 
1, 0.00548689, 0, 0, 0.491782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0324908,-99) , 
29, 32.0267, 1, 0, 0.486995,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.208111);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.19979,-99) , 
21, 39.6774, 0, 0, 0.49473,-99) , 
NN(
0, 
0, 
-1, 0.0708238, 1, -1, 0.387992,-99) , 
49, 2.18038, 0, 0, 0.439844,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.186667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494006,-99) , 
49, 2.76072, 0, 0, 0.525559,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.77103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.219928,-99) , 
48, 3.06685, 1, 0, 0.350755,-99) , 
50, 0.196048, 0, 0, 0.495064,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.175358);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490974,-99) , 
46, -2.3306, 1, 0, 0.523091,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.248416,-99) , 
1, -0.281214, 1, 0, 0.337227,-99) , 
21, 44.3822, 0, 0, 0.486337,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.127482);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524931,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0680947,-99) , 
23, 1.30889, 0, 0, 0.5177,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.914136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.220927,-99) , 
51, 33.8241, 0, 0, 0.283061,-99) , 
47, 2.93885, 1, 0, 0.498242,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.174145);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471642,-99) , 
20, 40.8331, 1, 0, 0.507635,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.245824,-99) , 
48, 3.0809, 1, 0, 0.349736,-99) , 
47, 2.73615, 1, 0, 0.487448,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.215938);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.314611,-99) , 
47, -2.93853, 0, 0, 0.542539,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.855911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357994,-99) , 
42, 0.337227, 0, 0, 0.378135,-99) , 
27, 22.5547, 0, 0, 0.514347,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.181196);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475321,-99) , 
45, -2.73623, 1, 0, 0.545887,-99) , 
NN(
0, 
0, 
-1, 46.0635, 0, -1, 0.425992,-99) , 
46, 0.506742, 0, 0, 0.462871,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0315291);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.256929, 0, 1, 0.507243,-99) , 
NN(
0, 
0, 
-1, 39.1711, 0, -1, 0.0682265,-99) , 
22, 2.55557, 0, 0, 0.501151,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.167332);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.71732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.180365,-99) , 
20, 29.205, 0, 0, 0.656712,-99) , 
NN(
0, 
0, 
-1, 22.2924, 0, -1, 0.467992,-99) , 
41, 0.935485, 0, 0, 0.503717,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.170468);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438802,-99) , 
30, -1.72273, 0, 0, 0.541172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 33.2788, 1, 0, 0.535883,-99)    );
   return;
};

// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
