// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.32/00       [401408]
Creator        : apranikstar
Date           : Mon Dec  9 19:12:01 2024
Host           : Darwin ChristoersMBP72.localdomain 23.5.0 Darwin Kernel Version 23.5.0: Wed May 1 20:12:58 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6000 arm64
Dir            : /Users/apranikstar/Desktop/FCC_Presentation/TMVAClassification/Muon/Hlnuqq
Training events: 385541
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "2" [Max depth of the decision tree allowed]
MinNodeSize: "0.5" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "6.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "7" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 52
Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       F                                 'F'    [-5.19514751434,5.2392334938]
Delta_rapidity_Muon_JNLO      Delta_rapidity_Muon_JNLO      Delta_rapidity_Muon_JNLO      Delta_rapidity_Muon_JNLO      F                                 'F'    [-5.19520664215,5.2392334938]
Delta_rapidity_Muon_JLO       Delta_rapidity_Muon_JLO       Delta_rapidity_Muon_JLO       Delta_rapidity_Muon_JLO       F                                 'F'    [-4.78941583633,4.90052318573]
JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               F                                 'F'    [-2.99855160713,2.99897766113]
JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                F                                 'F'    [-2.74659824371,2.82971000671]
Muon_Rapidity                 Muon_Rapidity                 Muon_Rapidity                 Muon_Rapidity                 F                                 'F'    [-2.56040263176,2.56004667282]
Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            F                                 'F'    [-6.36412143707,5.79184865952]
Delta_eta_Muon_NJO            Delta_eta_Muon_NJO            Delta_eta_Muon_NJO            Delta_eta_Muon_NJO            F                                 'F'    [-5.44139814377,5.596596241]
Delta_eta_Muon_JLO            Delta_eta_Muon_JLO            Delta_eta_Muon_JLO            Delta_eta_Muon_JLO            F                                 'F'    [-4.798828125,4.91808271408]
JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    F                                 'F'    [-4.33213281631,4.16897344589]
JetLO_eta                     JetLO_eta                     JetLO_eta                     JetLO_eta                     F                                 'F'    [-3.94285011292,3.63209414482]
Muon_eta                      Muon_eta                      Muon_eta                      Muon_eta                      F                                 'F'    [-2.56076645851,2.56027984619]
PT_Muon                       PT_Muon                       PT_Muon                       PT_Muon                       F                                 'F'    [1.62249648571,52.4335441589]
PT_JNLO                       PT_JNLO                       PT_JNLO                       PT_JNLO                       F                                 'F'    [1.0001103878,49.4518318176]
PT_JLO                        PT_JLO                        PT_JLO                        PT_JLO                        F                                 'F'    [1.30636429787,52.4370269775]
Energy_Transverse_Muon        Energy_Transverse_Muon        Energy_Transverse_Muon        Energy_Transverse_Muon        F                                 'F'    [1.62258172035,52.4336471558]
Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        F                                 'F'    [1.00019741058,52.3960151672]
Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         F                                 'F'    [1.36527431011,52.4379234314]
Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         F                                 'F'    [0.0141000300646,55.4164276123]
Energy_Muon                   Energy_Muon                   Energy_Muon                   Energy_Muon                   F                                 'F'    [10.0000734329,52.4495925903]
Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   F                                 'F'    [1.00489532948,52.4492607117]
Energy_JLO                    Energy_JLO                    Energy_JLO                    Energy_JLO                    F                                 'F'    [1.76850414276,52.4499588013]
M_JLO                         M_JLO                         M_JLO                         M_JLO                         F                                 'F'    [-0.0285523924977,41.1239814758]
M_JNLO                        M_JNLO                        M_JNLO                        M_JNLO                        F                                 'F'    [-0.0262650847435,39.7151985168]
M_Muon                        M_Muon                        M_Muon                        M_Muon                        F                                 'F'    [0.101904734969,0.109375342727]
M_met                         M_met                         M_met                         M_met                         F                                 'F'    [-0.0205634497106,0.0209629554302]
MT_Muon                       MT_Muon                       MT_Muon                       MT_Muon                       F                                 'F'    [1.62593460083,52.4336471558]
MT_JNLO                       MT_JNLO                       MT_JNLO                       MT_JNLO                       F                                 'F'    [1.00019824505,52.3968315125]
MT_JLO                        MT_JLO                        MT_JLO                        MT_JLO                        F                                 'F'    [1.73782324791,52.4379310608]
MT_met                        MT_met                        MT_met                        MT_met                        F                                 'F'    [0.0149544868618,55.4164276123]
Phi_Muon                      Phi_Muon                      Phi_Muon                      Phi_Muon                      F                                 'F'    [-3.1415886879,3.14156913757]
Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      F                                 'F'    [-3.14157986641,3.14159035683]
Phi_JLO                       Phi_JLO                       Phi_JLO                       Phi_JLO                       F                                 'F'    [-3.14157056808,3.14156913757]
Theta_Muon                    Theta_Muon                    Theta_Muon                    Theta_Muon                    F                                 'F'    [0.154259592295,2.98740792274]
Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    F                                 'F'    [0.0309337954968,3.1153151989]
Theta_JLO                     Theta_JLO                     Theta_JLO                     Theta_JLO                     F                                 'F'    [0.0529090799391,3.10281181335]
cosTheta_Muon                 cosTheta_Muon                 cosTheta_Muon                 cosTheta_Muon                 F                                 'F'    [-0.988137066364,0.988125562668]
cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 F                                 'F'    [-0.999654769897,0.999521613121]
cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  F                                 'F'    [-0.999248087406,0.998600661755]
CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             F                                 'F'    [-0.999997854233,0.0707292184234]
CosAngle_Muon_JNLO            CosAngle_Muon_JNLO            CosAngle_Muon_JNLO            CosAngle_Muon_JNLO            F                                 'F'    [-0.99999499321,1]
CosAngle_Muon_JLO             CosAngle_Muon_JLO             CosAngle_Muon_JLO             CosAngle_Muon_JLO             F                                 'F'    [-0.999997854233,1]
Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             F                                 'F'    [2.68931302116e-07,0.499153077602]
Aplanarity                    Aplanarity                    Aplanarity                    Aplanarity                    F                                 'F'    [-6.81473687329e-16,0.14452393353]
Sphericity                    Sphericity                    Sphericity                    Sphericity                    F                                 'F'    [4.03396938964e-07,0.783724009991]
DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             F                                 'F'    [-3.14157986641,3.14159083366]
DeltaPhi_Muon_JNLO            DeltaPhi_Muon_JNLO            DeltaPhi_Muon_JNLO            DeltaPhi_Muon_JNLO            F                                 'F'    [-3.14156270027,3.14158177376]
DeltaPhi_Muon_JLO             DeltaPhi_Muon_JLO             DeltaPhi_Muon_JLO             DeltaPhi_Muon_JLO             F                                 'F'    [-3.14157986641,3.14153409004]
DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               F                                 'F'    [1.50067317486,6.36544752121]
DeltaR_Muon_JLO               DeltaR_Muon_JLO               DeltaR_Muon_JLO               DeltaR_Muon_JLO               F                                 'F'    [0,5.46648406982]
DeltaR_Muon_JNLO              DeltaR_Muon_JNLO              DeltaR_Muon_JNLO              DeltaR_Muon_JNLO              F                                 'F'    [0,5.99794483185]
Energy_MET                    Energy_MET                    Energy_MET                    Energy_MET                    F                                 'F'    [20.0001487732,55.878112793]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTNode

#ifndef BDTNode__def
#define BDTNode__def

class BDTNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 52 )
   {
      // the training input variables
      const char* inputVars[] = { "Delta_rapidity_JNLO_JLO", "Delta_rapidity_Muon_JNLO", "Delta_rapidity_Muon_JLO", "JetNLO_Rapidity", "JetLO_Rapidity", "Muon_Rapidity", "Delta_eta_JLO_JNLO", "Delta_eta_Muon_NJO", "Delta_eta_Muon_JLO", "JetNLO_eta", "JetLO_eta", "Muon_eta", "PT_Muon", "PT_JNLO", "PT_JLO", "Energy_Transverse_Muon", "Energy_Transverse_JNLO", "Energy_Transverse_JLO", "Energy_Transverse_met", "Energy_Muon", "Energy_JNLO", "Energy_JLO", "M_JLO", "M_JNLO", "M_Muon", "M_met", "MT_Muon", "MT_JNLO", "MT_JLO", "MT_met", "Phi_Muon", "Phi_JNLO", "Phi_JLO", "Theta_Muon", "Theta_JNLO", "Theta_JLO", "cosTheta_Muon", "cosTheta_JNLO", "cosTheta_JLO", "CosAngle_JNLO_JLO", "CosAngle_Muon_JNLO", "CosAngle_Muon_JLO", "Linear_Aplanarity", "Aplanarity", "Sphericity", "DeltaPhi_JNLO_JLO", "DeltaPhi_Muon_JNLO", "DeltaPhi_Muon_JLO", "DeltaR_JNLO_JLO", "DeltaR_Muon_JLO", "DeltaR_Muon_JNLO", "Energy_MET" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;
      fVmin[29] = 0;
      fVmax[29] = 0;
      fVmin[30] = 0;
      fVmax[30] = 0;
      fVmin[31] = 0;
      fVmax[31] = 0;
      fVmin[32] = 0;
      fVmax[32] = 0;
      fVmin[33] = 0;
      fVmax[33] = 0;
      fVmin[34] = 0;
      fVmax[34] = 0;
      fVmin[35] = 0;
      fVmax[35] = 0;
      fVmin[36] = 0;
      fVmax[36] = 0;
      fVmin[37] = 0;
      fVmax[37] = 0;
      fVmin[38] = 0;
      fVmax[38] = 0;
      fVmin[39] = 0;
      fVmax[39] = 0;
      fVmin[40] = 0;
      fVmax[40] = 0;
      fVmin[41] = 0;
      fVmax[41] = 0;
      fVmin[42] = 0;
      fVmax[42] = 0;
      fVmin[43] = 0;
      fVmax[43] = 0;
      fVmin[44] = 0;
      fVmax[44] = 0;
      fVmin[45] = 0;
      fVmax[45] = 0;
      fVmin[46] = 0;
      fVmax[46] = 0;
      fVmin[47] = 0;
      fVmax[47] = 0;
      fVmin[48] = 0;
      fVmax[48] = 0;
      fVmin[49] = 0;
      fVmax[49] = 0;
      fVmin[50] = 0;
      fVmax[50] = 0;
      fVmin[51] = 0;
      fVmax[51] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';
      fType[29] = 'F';
      fType[30] = 'F';
      fType[31] = 'F';
      fType[32] = 'F';
      fType[33] = 'F';
      fType[34] = 'F';
      fType[35] = 'F';
      fType[36] = 'F';
      fType[37] = 'F';
      fType[38] = 'F';
      fType[39] = 'F';
      fType[40] = 'F';
      fType[41] = 'F';
      fType[42] = 'F';
      fType[43] = 'F';
      fType[44] = 'F';
      fType[45] = 'F';
      fType[46] = 'F';
      fType[47] = 'F';
      fType[48] = 'F';
      fType[49] = 'F';
      fType[50] = 'F';
      fType[51] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[52];
   double fVmax[52];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[52];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.92323823236418);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.981708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312977,-99) , 
41, -0.74192, 0, 0, 0.958224,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.941831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0471675,-99) , 
19, 31.9061, 0, 0, 0.0984243,-99) , 
18, 16.0132, 0, 0, 0.494934,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.4931);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.965594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498743,-99) , 
18, 7.28502, 0, 0, 0.93585,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.888165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0856297,-99) , 
20, 24.2451, 1, 0, 0.176679,-99) , 
39, -0.723671, 0, 0, 0.54478,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.18458);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.21041, 0, 1, 0.909508,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.753547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.113599,-99) , 
13, 17.4756, 1, 0, 0.27198,-99) , 
48, 3.03137, 1, 0, 0.551535,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.877756);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.860713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.311364,-99) , 
23, 1.18821, 0, 0, 0.762456,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0649099,-99) , 
18, 9.90806, 0, 0, 0.24016,-99) , 
39, -0.758219, 0, 0, 0.547586,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.74163);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.703685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.199028,-99) , 
44, 0.0483063, 0, 0, 0.654611,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.85299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0583982,-99) , 
23, 3.69118, 1, 0, 0.125369,-99) , 
41, -0.741895, 0, 0, 0.506773,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.675038);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.704103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329383,-99) , 
22, 1.30138, 0, 0, 0.614461,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0828259,-99) , 
19, 23.6937, 0, 0, 0.20256,-99) , 
39, -0.758225, 0, 0, 0.43198,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.573807);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34857,-99) , 
23, 2.51655, 0, 0, 0.611867,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0927131,-99) , 
13, 23.4277, 1, 0, 0.26822,-99) , 
48, 3.03352, 1, 0, 0.412067,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.592993);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.133495,-99) , 
27, 12.5465, 0, 0, 0.523398,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.828724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0917237,-99) , 
20, 20.9278, 1, 0, 0.230091,-99) , 
19, 19.5857, 0, 0, 0.418151,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.47811);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351706,-99) , 
14, 34.5077, 1, 0, 0.464138,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.696337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.119019,-99) , 
43, 0.0025769, 0, 0, 0.183517,-99) , 
39, -0.792758, 0, 0, 0.378912,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.437197);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.779787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434632,-99) , 
19, 48.3416, 0, 0, 0.481321,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.103202,-99) , 
48, 3.09932, 1, 0, 0.189009,-99) , 
39, -0.792749, 0, 0, 0.393629,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.375128);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.257985,-99) , 
13, 31.8885, 1, 0, 0.50923,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616105,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.131204,-99) , 
43, 0.0025769, 0, 0, 0.181934,-99) , 
39, -0.792758, 0, 0, 0.408414,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.338114);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396347,-99) , 
22, 15.9021, 0, 0, 0.454401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0733054,-99) , 
29, 3.65454, 0, 0, 0.411963,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.400461);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.770068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.02154,-99) , 
20, 24.2318, 0, 0, 0.69459,-99) , 
NN(
0, 
0, 
-1, 40.8327, 1, -1, 0.36616,-99) , 
19, 45.6029, 0, 0, 0.42274,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.241327);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 25.7485, 1, 1, 0.558522,-99) , 
NN(
0, 
0, 
-1, 24.1923, 1, -1, 0.274572,-99) , 
39, -0.79276, 0, 0, 0.489285,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.390618);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.325832,-99) , 
23, 2.43194, 0, 0, 0.514254,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.787617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.129683,-99) , 
23, 3.52489, 1, 0, 0.243267,-99) , 
49, 2.99775, 1, 0, 0.448039,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.246462);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.735039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456075,-99) , 
19, 49.7108, 0, 0, 0.476591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.771425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.1187,-99) , 
39, -0.620095, 0, 0, 0.188134,-99) , 
18, 5.40526, 0, 0, 0.436518,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.384048);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.211176,-99) , 
22, 1.95133, 0, 0, 0.614241,-99) , 
NN(
0, 
0, 
-1, 0.354858, 0, -1, 0.377222,-99) , 
21, 39.833, 1, 0, 0.463355,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.339476);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0936991,-99) , 
47, -2.9389, 0, 0, 0.563057,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101041,-99) , 
19, 33.273, 0, 0, 0.273407,-99) , 
20, 40.8328, 1, 0, 0.494661,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.33742);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.656968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431914,-99) , 
23, 10.7807, 0, 0, 0.513096,-99) , 
NN(
0, 
0, 
-1, 36.0142, 0, -1, 0.265025,-99) , 
20, 39.1747, 1, 0, 0.445291,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.169037);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.276828,-99) , 
47, 2.93885, 1, 0, 0.518379,-99) , 
NN(
0, 
0, 
-1, -0.0317673, 0, -1, 0.0436107,-99) , 
13, 35.3853, 1, 0, 0.498713,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.280468);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447187,-99) , 
29, 25.0541, 1, 0, 0.529522,-99) , 
NN(
0, 
0, 
-1, 30.5365, 0, -1, 0.277204,-99) , 
20, 40.8327, 1, 0, 0.476703,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.127011);
  fForest.push_back( 
NN(
0, 
0, 
-1, 3.58585, 0, -1, 0.447275,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.130381);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492057,-99) , 
51, 23.4473, 1, 0, 0.519781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.173379,-99) , 
18, 3.56758, 0, 0, 0.495541,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.13539);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00456049, 0, 1, 0.531003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.139933,-99) , 
18, 3.58844, 0, 0, 0.501088,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.156727);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.196381,-99) , 
27, 5.79787, 0, 0, 0.516022,-99) , 
NN(
0, 
0, 
-1, 1.62498, 1, -1, 0.0443077,-99) , 
13, 35.2593, 1, 0, 0.495428,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.104915);
  fForest.push_back( 
NN(
0, 
0, 
-1, 3.60336, 0, -1, 0.456396,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.165271);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386437,-99) , 
22, 3.95395, 0, 0, 0.488627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.169907,-99) , 
18, 3.57707, 0, 0, 0.468686,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.314263);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.725507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479724,-99) , 
29, 16.0838, 1, 0, 0.539398,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.740919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.229003,-99) , 
48, 3.05038, 1, 0, 0.337525,-99) , 
39, -0.75821, 0, 0, 0.479282,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.179194);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.236323,-99) , 
47, 2.93885, 1, 0, 0.523011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.174142,-99) , 
18, 3.57707, 0, 0, 0.499264,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.222084);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345524,-99) , 
0, 1.41026, 1, 0, 0.501726,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0575679,-99) , 
16, 24.5882, 1, 0, 0.252913,-99) , 
41, -0.677405, 0, 0, 0.463091,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.205691);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425052,-99) , 
49, 0.167982, 0, 0, 0.489283,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.754698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0759443,-99) , 
12, 18.5322, 0, 0, 0.197348,-99) , 
47, -2.93881, 0, 0, 0.471591,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.197903);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322293,-99) , 
20, 40.8328, 1, 0, 0.501672,-99) , 
NN(
0, 
0, 
-1, 39.83, 1, -1, 0.28071,-99) , 
49, 3.02368, 1, 0, 0.46259,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.301568);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.143453,-99) , 
20, 25.7411, 0, 0, 0.600115,-99) , 
NN(
0, 
0, 
-1, 29.185, 1, -1, 0.406956,-99) , 
26, 34.3997, 0, 0, 0.454323,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.166831);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436571,-99) , 
20, 35.8542, 0, 0, 0.487293,-99) , 
NN(
0, 
0, 
-1, 20.0359, 0, -1, 0.0834438,-99) , 
13, 35.3852, 1, 0, 0.474307,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0728988);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.237945,-99) , 
47, -2.93888, 0, 0, 0.493744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00972189,-99) , 
13, 36.3539, 1, 0, 0.483048,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.207428);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628811,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440071,-99) , 
51, 25.7869, 1, 0, 0.473639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.149274,-99) , 
18, 3.58844, 0, 0, 0.458038,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.228509);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422584,-99) , 
22, 9.65009, 0, 0, 0.564919,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0616989,-99) , 
40, 0.935486, 1, 0, 0.442744,-99) , 
21, 39.5418, 1, 0, 0.485744,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.25789);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.265372,-99) , 
22, 1.91541, 0, 0, 0.565251,-99) , 
NN(
0, 
0, 
-1, 0.935485, 1, -1, 0.423401,-99) , 
21, 41.1553, 1, 0, 0.477086,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.131931);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.890411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.212629,-99) , 
27, 17.2765, 0, 0, 0.794234,-99) , 
NN(
0, 
0, 
-1, 5.42623, 0, -1, 0.459266,-99) , 
21, 23.4069, 1, 0, 0.47328,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.284404);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412731,-99) , 
23, 1.94287, 0, 0, 0.553201,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.769763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.314518,-99) , 
23, 2.51549, 1, 0, 0.372491,-99) , 
20, 39.173, 1, 0, 0.506186,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.171143);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307329,-99) , 
19, 14.1082, 0, 0, 0.501748,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.764138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0590175,-99) , 
49, 0.171368, 0, 0, 0.228548,-99) , 
44, 0.0252818, 0, 0, 0.486853,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0908119);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361299,-99) , 
45, 2.93889, 1, 0, 0.490527,-99) , 
NN(
0, 
0, 
-1, 0.15316, 0, -1, 0.0721021,-99) , 
13, 35.3852, 1, 0, 0.479565,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.101421);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.865152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471199,-99) , 
14, 11.6987, 1, 0, 0.478299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0379832,-99) , 
13, 36.1787, 1, 0, 0.470779,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.144609);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.798304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423072,-99) , 
18, 16.0056, 1, 0, 0.67776,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.318814,-99) , 
39, -0.79276, 0, 0, 0.474556,-99) , 
14, 21.0951, 1, 0, 0.497872,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.163493);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 11.6042, 0, 1, 0.652065,-99) , 
NN(
0, 
0, 
-1, 3.11383, 1, -1, 0.439922,-99) , 
14, 19.673, 1, 0, 0.457508,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.129248);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479004,-99) , 
47, 0.388891, 0, 0, 0.500779,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0105969,-99) , 
14, 34.2979, 1, 0, 0.287139,-99) , 
47, 2.93885, 1, 0, 0.486788,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.13172);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492942,-99) , 
21, 38.4445, 1, 0, 0.525772,-99) , 
NN(
0, 
0, 
-1, -0.787711, 0, -1, 0.369464,-99) , 
20, 40.8345, 1, 0, 0.495979,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0961009);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.827638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.159557,-99) , 
20, 32.5328, 0, 0, 0.76595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0646102,-99) , 
13, 35.3852, 1, 0, 0.495164,-99) , 
19, 49.7106, 0, 0, 0.514284,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.221016);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.79209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.326792,-99) , 
20, 35.4831, 0, 0, 0.606975,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329698,-99) , 
16, 25.8692, 1, 0, 0.450638,-99) , 
26, 37.6797, 0, 0, 0.480661,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.282258);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357324,-99) , 
20, 33.9783, 0, 0, 0.589136,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367809,-99) , 
20, 27.557, 1, 0, 0.435769,-99) , 
12, 37.6868, 0, 0, 0.463985,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0767133);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491866,-99) , 
19, 49.7108, 0, 0, 0.506508,-99) , 
NN(
0, 
0, 
-1, 18.0192, 0, -1, 0.152767,-99) , 
27, 39.1332, 1, 0, 0.495344,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.148353);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452057,-99) , 
28, 38.0962, 1, 0, 0.510982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101754,-99) , 
49, 3.87944, 1, 0, 0.504439,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.384186);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.21591,-99) , 
20, 22.577, 0, 0, 0.594151,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.686189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35343,-99) , 
43, 0.00466206, 0, 0, 0.416382,-99) , 
26, 26.209, 0, 0, 0.495021,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.165721);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.868034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446514,-99) , 
13, 16.6695, 0, 0, 0.777384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442378,-99) , 
21, 39.542, 1, 0, 0.485366,-99) , 
19, 51.0799, 0, 0, 0.496603,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.207906);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336942,-99) , 
45, -3.0631, 0, 0, 0.578592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446672,-99) , 
46, -2.12814, 1, 0, 0.476709,-99) , 
45, -1.92546, 1, 0, 0.510803,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.285957);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408116,-99) , 
20, 27.5709, 1, 0, 0.566919,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320004,-99) , 
20, 34.1954, 0, 0, 0.458149,-99) , 
22, 14.1852, 0, 0, 0.500188,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.190757);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.52954, 1, 1, 0.571649,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526986,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.19173,-99) , 
23, 2.47139, 0, 0, 0.457064,-99) , 
22, 11.6037, 0, 0, 0.51297,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0672757);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.907196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486868,-99) , 
14, 10.0711, 1, 0, 0.49374,-99) , 
NN(
0, 
0, 
-1, 2.70896, 1, -1, 0.133139,-99) , 
13, 35.0152, 1, 0, 0.484989,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.174717);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.875598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49068,-99) , 
23, 2.55003, 1, 0, 0.560476,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.204089,-99) , 
23, 3.65447, 0, 0, 0.441293,-99) , 
22, 11.603, 0, 0, 0.501375,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.267795);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424708,-99) , 
20, 29.2285, 1, 0, 0.553136,-99) , 
NN(
0, 
0, 
-1, 25.897, 0, -1, 0.41001,-99) , 
22, 11.6037, 0, 0, 0.481619,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.153799);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481304,-99) , 
22, 11.9197, 0, 0, 0.537225,-99) , 
NN(
0, 
0, 
-1, 2.72119, 1, -1, 0.132002,-99) , 
13, 35.0151, 1, 0, 0.527786,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.172844);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390366,-99) , 
1, -1.53393, 0, 0, 0.532909,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.846923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.120579,-99) , 
19, 25.061, 0, 0, 0.305081,-99) , 
47, 2.93885, 1, 0, 0.520176,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.15355);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.885496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415533,-99) , 
50, 0.940662, 0, 0, 0.824655,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446406,-99) , 
19, 36.0175, 0, 0, 0.502849,-99) , 
14, 14.5005, 1, 0, 0.515967,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.139242);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.816705,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493861,-99) , 
23, 2.53288, 1, 0, 0.551295,-99) , 
NN(
0, 
0, 
-1, 25.8971, 0, -1, 0.445491,-99) , 
22, 11.919, 0, 0, 0.495468,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.233564);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385831,-99) , 
22, 2.27946, 0, 0, 0.540287,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.788299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3949,-99) , 
39, -0.896377, 1, 0, 0.418609,-99) , 
21, 47.683, 1, 0, 0.493831,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.122644);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.861828, 1, 1, 0.53505,-99) , 
NN(
0, 
0, 
-1, 15.4817, 0, -1, 0.386777,-99) , 
20, 40.8329, 1, 0, 0.504941,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0952214);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485241,-99) , 
18, 16.073, 1, 0, 0.511758,-99) , 
NN(
0, 
0, 
-1, 0.677573, 0, -1, 0.102562,-99) , 
16, 39.0943, 1, 0, 0.505082,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.129265);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.857331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372895,-99) , 
19, 26.4325, 1, 0, 0.783798,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4705,-99) , 
51, 46.6193, 0, 0, 0.493831,-99) , 
14, 14.759, 1, 0, 0.503864,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.116659);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.119458,-99) , 
49, 3.91423, 1, 0, 0.533738,-99) , 
NN(
0, 
0, 
-1, 40.1558, 1, -1, 0.132399,-99) , 
27, 39.1335, 1, 0, 0.525229,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.123183);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482529,-99) , 
21, 38.256, 1, 0, 0.508691,-99) , 
NN(
0, 
0, 
-1, 29.1669, 0, -1, 0.327965,-99) , 
20, 45.8109, 1, 0, 0.487452,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.280707);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.161016,-99) , 
20, 24.2349, 0, 0, 0.598178,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400595,-99) , 
13, 16.6298, 1, 0, 0.480648,-99) , 
19, 38.7558, 0, 0, 0.529788,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.114593);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 38.2105, 1, 1, 0.532153,-99) , 
NN(
0, 
0, 
-1, 0.0724586, 0, -1, 0.384462,-99) , 
21, 36.1009, 0, 0, 0.504789,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.063651);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.898341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.193177,-99) , 
23, 1.16199, 0, 0, 0.766065,-99) , 
NN(
0, 
0, 
-1, 3.58844, 0, -1, 0.486368,-99) , 
14, 14.759, 1, 0, 0.496157,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0791476);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492883,-99) , 
14, 23.091, 1, 0, 0.510362,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.120926,-99) , 
49, 0.176338, 0, 0, 0.240715,-99) , 
44, 0.0252827, 0, 0, 0.501009,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.103513);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479872,-99) , 
45, 2.33085, 0, 0, 0.504757,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.059611,-99) , 
22, 8.90154, 0, 0, 0.250636,-99) , 
44, 0.0252818, 0, 0, 0.496502,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.127194);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.176605,-99) , 
13, 35.3852, 1, 0, 0.539701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.16874,-99) , 
24, 0.107702, 1, 0, 0.534486,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.127269);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338125,-99) , 
41, -0.80645, 0, 0, 0.518739,-99) , 
NN(
0, 
0, 
-1, 2.33819, 0, -1, 0.368261,-99) , 
7, 1.58046, 1, 0, 0.500005,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0938332);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476158,-99) , 
19, 49.7108, 0, 0, 0.488536,-99) , 
NN(
0, 
0, 
-1, 15.104, 1, -1, 0.106498,-99) , 
41, -0.935482, 0, 0, 0.482135,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.075123);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290934,-99) , 
47, 2.93883, 1, 0, 0.500937,-99) , 
NN(
0, 
0, 
-1, -0.504998, 1, -1, 0.147544,-99) , 
27, 39.0778, 1, 0, 0.492534,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0868853);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517676,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.241578,-99) , 
1, -2.22838, 0, 0, 0.510173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0851755,-99) , 
19, 25.0336, 0, 0, 0.214157,-99) , 
47, -2.93889, 0, 0, 0.4998,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0723816);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489543,-99) , 
51, 47.5774, 0, 0, 0.504344,-99) , 
NN(
0, 
0, 
-1, 19.6008, 0, -1, 0.0877543,-99) , 
16, 39.1326, 1, 0, 0.496797,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0745243);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385155,-99) , 
37, 0.87055, 1, 0, 0.492789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272301,-99) , 
18, 3.58844, 0, 0, 0.484262,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.14876);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458498,-99) , 
19, 49.7107, 0, 0, 0.470889,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.653202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.225063,-99) , 
19, 23.7177, 1, 0, 0.301347,-99) , 
1, 1.87358, 1, 0, 0.460052,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.162722);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423393,-99) , 
20, 39.1733, 1, 0, 0.520787,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.236666,-99) , 
51, 39.6756, 0, 0, 0.333505,-99) , 
0, 1.9788, 1, 0, 0.506918,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0882666);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48603,-99) , 
14, 21.7498, 1, 0, 0.500142,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.678511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.190605,-99) , 
27, 18.4155, 0, 0, 0.283358,-99) , 
44, 0.0252818, 0, 0, 0.490538,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0949976);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498138,-99) , 
21, 38.5223, 1, 0, 0.526532,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.843946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.191748,-99) , 
8, 0.107598, 0, 0, 0.28329,-99) , 
44, 0.0241537, 0, 0, 0.517626,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.14531);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417376,-99) , 
1, -1.21203, 0, 0, 0.52221,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.265819,-99) , 
23, 7.66625, 1, 0, 0.360942,-99) , 
20, 47.4707, 1, 0, 0.50855,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0815999);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483879,-99) , 
14, 23.36, 1, 0, 0.498811,-99) , 
NN(
0, 
0, 
-1, 7.03992, 0, -1, 0.28563,-99) , 
44, 0.0240957, 0, 0, 0.490993,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.147143);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461008,-99) , 
26, 22.9324, 0, 0, 0.517809,-99) , 
NN(
0, 
0, 
-1, 1.15668, 0, -1, 0.415049,-99) , 
1, 0.910683, 1, 0, 0.498228,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0453525);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 21.0466, 1, 1, 0.515842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00836617,-99) , 
13, 36.9482, 1, 0, 0.512593,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.114656);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472846,-99) , 
22, 11.6044, 0, 0, 0.513262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.280038,-99) , 
18, 3.58844, 0, 0, 0.504623,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.06546);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.299001,-99) , 
47, -2.93889, 0, 0, 0.503127,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.113927,-99) , 
49, 0.171196, 0, 0, 0.252297,-99) , 
44, 0.0241536, 0, 0, 0.494213,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0368026);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.239664,-99) , 
27, 4.68904, 0, 0, 0.496789,-99) , 
NN(
0, 
0, 
-1, 0.871019, 0, -1, 0.15061,-99) , 
27, 39.1193, 1, 0, 0.491249,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.107595);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 8.98131, 1, 1, 0.531076,-99) , 
NN(
0, 
0, 
-1, 5.37562, 0, -1, 0.448822,-99) , 
42, 0.161018, 0, 0, 0.475283,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0438044);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491504,-99) , 
19, 51.0803, 0, 0, 0.49841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0340082,-99) , 
13, 36.8165, 1, 0, 0.494963,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.131252);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482992,-99) , 
29, 15.8428, 1, 0, 0.519813,-99) , 
NN(
0, 
0, 
-1, 0.935486, 1, -1, 0.420857,-99) , 
28, 42.625, 1, 0, 0.488964,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0666207);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.304521,-99) , 
27, 5.96371, 0, 0, 0.511029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.044976,-99) , 
13, 36.8165, 1, 0, 0.507269,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.143655);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.718873,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491346,-99) , 
18, 8.98019, 1, 0, 0.510631,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.150071,-99) , 
16, 20.8753, 1, 0, 0.415517,-99) , 
19, 18.2165, 0, 0, 0.493786,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.036368);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496683,-99) , 
29, 44.7067, 0, 0, 0.50613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.029678,-99) , 
13, 36.9482, 1, 0, 0.50319,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.238742);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.243377,-99) , 
27, 7.59803, 0, 0, 0.541542,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.727086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.247615,-99) , 
20, 19.2672, 1, 0, 0.419778,-99) , 
19, 18.2161, 0, 0, 0.51796,-99)    );
   return;
};

// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
