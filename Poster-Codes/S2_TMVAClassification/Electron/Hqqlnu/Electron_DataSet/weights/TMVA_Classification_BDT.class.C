// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.32/00       [401408]
Creator        : apranikstar
Date           : Mon Dec  9 18:16:24 2024
Host           : Darwin ChristoersMBP72.localdomain 23.5.0 Darwin Kernel Version 23.5.0: Wed May 1 20:12:58 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6000 arm64
Dir            : /Users/apranikstar/Desktop/FCC_Presentation/TMVAClassification/Electron/Hqqlnu
Training events: 323925
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "2" [Max depth of the decision tree allowed]
MinNodeSize: "0.5" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "6.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "7" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 52
Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       Delta_rapidity_JNLO_JLO       F                                 'F'    [-5.25497627258,5.12944602966]
Delta_rapidity_electron_JNLO  Delta_rapidity_electron_JNLO  Delta_rapidity_electron_JNLO  Delta_rapidity_electron_JNLO  F                                 'F'    [-5.17370891571,5.12944602966]
Delta_rapidity_electron_JLO   Delta_rapidity_electron_JLO   Delta_rapidity_electron_JLO   Delta_rapidity_electron_JLO   F                                 'F'    [-5.02751731873,5.25497627258]
JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               JetNLO_Rapidity               F                                 'F'    [-2.99909186363,2.99530434608]
JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                JetLO_Rapidity                F                                 'F'    [-2.84084367752,2.92613220215]
electron_Rapidity             electron_Rapidity             electron_Rapidity             electron_Rapidity             F                                 'F'    [-2.56099104881,2.56050848961]
Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            Delta_eta_JLO_JNLO            F                                 'F'    [-6.78954601288,6.24250888824]
Delta_eta_electron_NJO        Delta_eta_electron_NJO        Delta_eta_electron_NJO        Delta_eta_electron_NJO        F                                 'F'    [-5.60817861557,5.36720848083]
Delta_eta_electron_JLO        Delta_eta_electron_JLO        Delta_eta_electron_JLO        Delta_eta_electron_JLO        F                                 'F'    [-5.08970928192,5.25497436523]
JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    JetNLO_eta                    F                                 'F'    [-4.37251996994,4.47162628174]
JetLO_eta                     JetLO_eta                     JetLO_eta                     JetLO_eta                     F                                 'F'    [-3.94285011292,3.77181124687]
electron_eta                  electron_eta                  electron_eta                  electron_eta                  F                                 'F'    [-2.56099152565,2.56050944328]
PT_electron                   PT_electron                   PT_electron                   PT_electron                   F                                 'F'    [1.57431578636,52.4370269775]
PT_JNLO                       PT_JNLO                       PT_JNLO                       PT_JNLO                       F                                 'F'    [1.0005248785,50.2852096558]
PT_JLO                        PT_JLO                        PT_JLO                        PT_JLO                        F                                 'F'    [1.30636429787,52.4370269775]
Energy_Transverse_electron    Energy_Transverse_electron    Energy_Transverse_electron    Energy_Transverse_electron    F                                 'F'    [1.57431578636,52.4370231628]
Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        Energy_Transverse_JNLO        F                                 'F'    [1.0005248785,52.3968658447]
Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         Energy_Transverse_JLO         F                                 'F'    [1.36527431011,52.4435081482]
Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         Energy_Transverse_met         F                                 'F'    [0.0571668893099,55.6596832275]
Energy_electron               Energy_electron               Energy_electron               Energy_electron               F                                 'F'    [10.0000286102,52.4494972229]
Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   Energy_JNLO                   F                                 'F'    [1.00633597374,52.4499664307]
Energy_JLO                    Energy_JLO                    Energy_JLO                    Energy_JLO                    F                                 'F'    [2.01426100731,52.449962616]
M_JLO                         M_JLO                         M_JLO                         M_JLO                         F                                 'F'    [-0.0285523924977,41.2708969116]
M_JNLO                        M_JNLO                        M_JNLO                        M_JNLO                        F                                 'F'    [-0.0279120020568,40.2533836365]
M_electron                    M_electron                    M_electron                    M_electron                    F                                 'F'    [-0.0285523924977,0.0281114205718]
M_met                         M_met                         M_met                         M_met                         F                                 'F'    [-0.0205634497106,0.0211179815233]
MT_electron                   MT_electron                   MT_electron                   MT_electron                   F                                 'F'    [1.57431340218,52.4370231628]
MT_JNLO                       MT_JNLO                       MT_JNLO                       MT_JNLO                       F                                 'F'    [1.0005248785,52.4143409729]
MT_JLO                        MT_JLO                        MT_JLO                        MT_JLO                        F                                 'F'    [2.0141980648,52.4439582825]
MT_met                        MT_met                        MT_met                        MT_met                        F                                 'F'    [0.0569661334157,55.6596832275]
Phi_electron                  Phi_electron                  Phi_electron                  Phi_electron                  F                                 'F'    [-3.14158439636,3.14156508446]
Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      Phi_JNLO                      F                                 'F'    [-3.14156723022,3.14157867432]
Phi_JLO                       Phi_JLO                       Phi_JLO                       Phi_JLO                       F                                 'F'    [-3.14155983925,3.14158415794]
Theta_electron                Theta_electron                Theta_electron                Theta_electron                F                                 'F'    [0.154224321246,2.98744225502]
Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    Theta_JNLO                    F                                 'F'    [0.0228564329445,3.11635518074]
Theta_JLO                     Theta_JLO                     Theta_JLO                     Theta_JLO                     F                                 'F'    [0.0460125766695,3.10281181335]
cosTheta_electron             cosTheta_electron             cosTheta_electron             cosTheta_electron             F                                 'F'    [-0.988142371178,0.988130986691]
cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 cosTheta_JNLO                 F                                 'F'    [-0.999681532383,0.999738812447]
cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  cosTheta_JLO                  F                                 'F'    [-0.999248087406,0.998941600323]
CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             CosAngle_JNLO_JLO             F                                 'F'    [-0.999982774258,0.0707348510623]
CosAngle_Electron_JNLO        CosAngle_Electron_JNLO        CosAngle_Electron_JNLO        CosAngle_Electron_JNLO        F                                 'F'    [-0.999991476536,1]
CosAngle_Electron_JLO         CosAngle_Electron_JLO         CosAngle_Electron_JLO         CosAngle_Electron_JLO         F                                 'F'    [-0.999997019768,1]
Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             Linear_Aplanarity             F                                 'F'    [2.88229529133e-07,0.498360097408]
Aplanarity                    Aplanarity                    Aplanarity                    Aplanarity                    F                                 'F'    [-4.99600361081e-16,0.142128154635]
Sphericity                    Sphericity                    Sphericity                    Sphericity                    F                                 'F'    [4.32344364754e-07,0.758121907711]
DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             DeltaPhi_JNLO_JLO             F                                 'F'    [-3.14158272743,3.14159226418]
DeltaPhi_electron_JNLO        DeltaPhi_electron_JNLO        DeltaPhi_electron_JNLO        DeltaPhi_electron_JNLO        F                                 'F'    [-3.14155220985,3.14157104492]
DeltaPhi_electron_JLO         DeltaPhi_electron_JLO         DeltaPhi_electron_JLO         DeltaPhi_electron_JLO         F                                 'F'    [-3.14153814316,3.14157295227]
DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               DeltaR_JNLO_JLO               F                                 'F'    [1.50067317486,6.90080404282]
DeltaR_electron_JLO           DeltaR_electron_JLO           DeltaR_electron_JLO           DeltaR_electron_JLO           F                                 'F'    [0,5.68727970123]
DeltaR_electron_JNLO          DeltaR_electron_JNLO          DeltaR_electron_JNLO          DeltaR_electron_JNLO          F                                 'F'    [0,6.02506113052]
Energy_MET                    Energy_MET                    Energy_MET                    Energy_MET                    F                                 'F'    [20.0000591278,55.878112793]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTNode

#ifndef BDTNode__def
#define BDTNode__def

class BDTNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 52 )
   {
      // the training input variables
      const char* inputVars[] = { "Delta_rapidity_JNLO_JLO", "Delta_rapidity_electron_JNLO", "Delta_rapidity_electron_JLO", "JetNLO_Rapidity", "JetLO_Rapidity", "electron_Rapidity", "Delta_eta_JLO_JNLO", "Delta_eta_electron_NJO", "Delta_eta_electron_JLO", "JetNLO_eta", "JetLO_eta", "electron_eta", "PT_electron", "PT_JNLO", "PT_JLO", "Energy_Transverse_electron", "Energy_Transverse_JNLO", "Energy_Transverse_JLO", "Energy_Transverse_met", "Energy_electron", "Energy_JNLO", "Energy_JLO", "M_JLO", "M_JNLO", "M_electron", "M_met", "MT_electron", "MT_JNLO", "MT_JLO", "MT_met", "Phi_electron", "Phi_JNLO", "Phi_JLO", "Theta_electron", "Theta_JNLO", "Theta_JLO", "cosTheta_electron", "cosTheta_JNLO", "cosTheta_JLO", "CosAngle_JNLO_JLO", "CosAngle_Electron_JNLO", "CosAngle_Electron_JLO", "Linear_Aplanarity", "Aplanarity", "Sphericity", "DeltaPhi_JNLO_JLO", "DeltaPhi_electron_JNLO", "DeltaPhi_electron_JLO", "DeltaR_JNLO_JLO", "DeltaR_electron_JLO", "DeltaR_electron_JNLO", "Energy_MET" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;
      fVmin[29] = 0;
      fVmax[29] = 0;
      fVmin[30] = 0;
      fVmax[30] = 0;
      fVmin[31] = 0;
      fVmax[31] = 0;
      fVmin[32] = 0;
      fVmax[32] = 0;
      fVmin[33] = 0;
      fVmax[33] = 0;
      fVmin[34] = 0;
      fVmax[34] = 0;
      fVmin[35] = 0;
      fVmax[35] = 0;
      fVmin[36] = 0;
      fVmax[36] = 0;
      fVmin[37] = 0;
      fVmax[37] = 0;
      fVmin[38] = 0;
      fVmax[38] = 0;
      fVmin[39] = 0;
      fVmax[39] = 0;
      fVmin[40] = 0;
      fVmax[40] = 0;
      fVmin[41] = 0;
      fVmax[41] = 0;
      fVmin[42] = 0;
      fVmax[42] = 0;
      fVmin[43] = 0;
      fVmax[43] = 0;
      fVmin[44] = 0;
      fVmax[44] = 0;
      fVmin[45] = 0;
      fVmax[45] = 0;
      fVmin[46] = 0;
      fVmax[46] = 0;
      fVmin[47] = 0;
      fVmax[47] = 0;
      fVmin[48] = 0;
      fVmax[48] = 0;
      fVmin[49] = 0;
      fVmax[49] = 0;
      fVmin[50] = 0;
      fVmax[50] = 0;
      fVmin[51] = 0;
      fVmax[51] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';
      fType[29] = 'F';
      fType[30] = 'F';
      fType[31] = 'F';
      fType[32] = 'F';
      fType[33] = 'F';
      fType[34] = 'F';
      fType[35] = 'F';
      fType[36] = 'F';
      fType[37] = 'F';
      fType[38] = 'F';
      fType[39] = 'F';
      fType[40] = 'F';
      fType[41] = 'F';
      fType[42] = 'F';
      fType[43] = 'F';
      fType[44] = 'F';
      fType[45] = 'F';
      fType[46] = 'F';
      fType[47] = 'F';
      fType[48] = 'F';
      fType[49] = 'F';
      fType[50] = 'F';
      fType[51] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[52];
   double fVmax[52];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[52];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.59928836838707);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.989548,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.300041,-99) , 
20, 37.5138, 0, 0, 0.897602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0609224,-99) , 
43, 0.00456172, 0, 0, 0.126652,-99) , 
18, 12.5142, 0, 0, 0.49313,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.22844);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.95432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.207361,-99) , 
50, 0.193153, 0, 0, 0.874346,-99) , 
NN(
0, 
0, 
-1, 0.552581, 0, -1, 0.166435,-99) , 
18, 10.6609, 0, 0, 0.523114,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.32658);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.917826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.273475,-99) , 
49, 0.177025, 0, 0, 0.82594,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.956603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0829338,-99) , 
48, 2.99889, 1, 0, 0.163646,-99) , 
50, 0.388714, 0, 0, 0.59142,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.733068);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.908816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479877,-99) , 
20, 44.1508, 0, 0, 0.72285,-99) , 
NN(
0, 
0, 
-1, 0.871027, 1, -1, 0.14756,-99) , 
18, 5.43806, 0, 0, 0.558287,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.850814);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 5.36989, 0, 1, 0.787154,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.844904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.164017,-99) , 
18, 15.8507, 0, 0, 0.306605,-99) , 
50, 0.386054, 0, 0, 0.617728,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.667995);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.786546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391112,-99) , 
49, 2.99524, 1, 0, 0.661065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.156859,-99) , 
18, 3.64443, 0, 0, 0.560297,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.629671);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.827312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497124,-99) , 
21, 46.3385, 0, 0, 0.724707,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.680953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.199226,-99) , 
48, 3.13599, 1, 0, 0.340315,-99) , 
18, 7.15268, 0, 0, 0.585658,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.645285);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.811194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442851,-99) , 
48, 3.06909, 1, 0, 0.742144,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.713015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.26137,-99) , 
18, 16.6014, 0, 0, 0.381847,-99) , 
48, 3.12135, 1, 0, 0.538784,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.556015);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 31.9093, 1, 0, 0.679781,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.183308,-99) , 
21, 47.5575, 0, 0, 0.373274,-99) , 
18, 7.1263, 0, 0, 0.589111,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.533294);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.750697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322149,-99) , 
50, 0.181565, 0, 0, 0.686453,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.794004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323266,-99) , 
27, 45.7316, 0, 0, 0.377107,-99) , 
22, 15.2411, 0, 0, 0.492421,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.377118);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62653,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.258144,-99) , 
18, 3.55211, 0, 0, 0.583457,-99) , 
NN(
0, 
0, 
-1, 0.736169, 0, -1, 0.0757686,-99) , 
51, 36.1775, 1, 0, 0.561768,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.45285);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.670013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386047,-99) , 
45, -2.94544, 0, 0, 0.555081,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.171857,-99) , 
23, 19.6247, 0, 0, 0.306849,-99) , 
45, 2.93891, 1, 0, 0.490255,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.396421);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.100823,-99) , 
51, 32.6155, 1, 0, 0.594793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.732827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342235,-99) , 
38, -0.740059, 1, 0, 0.374495,-99) , 
21, 49.2719, 0, 0, 0.459011,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.446297);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331116,-99) , 
12, 6.40116, 0, 0, 0.545563,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.186785,-99) , 
8, 0.706006, 0, 0, 0.262835,-99) , 
20, 42.4939, 0, 0, 0.441093,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.375082);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452795,-99) , 
18, 12.5586, 1, 0, 0.578897,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.281064,-99) , 
39, -0.863364, 1, 0, 0.376715,-99) , 
41, -0.290321, 0, 0, 0.478988,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.220804);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0711957,-99) , 
51, 36.2031, 1, 0, 0.527039,-99) , 
NN(
0, 
0, 
-1, -0.827452, 1, -1, 0.198729,-99) , 
47, 2.93889, 1, 0, 0.487431,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.288998);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 35.8658, 1, 1, 0.617014,-99) , 
NN(
0, 
0, 
-1, 2.93889, 1, -1, 0.380832,-99) , 
37, -0.225715, 1, 0, 0.49345,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0972075);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.770886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49924,-99) , 
24, -0.00573286, 1, 0, 0.53027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 34.6482, 1, 0, 0.520308,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.391869);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.253212,-99) , 
20, 30.8768, 0, 0, 0.571687,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.75809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.30359,-99) , 
38, -0.737878, 1, 0, 0.342594,-99) , 
40, 0.870969, 1, 0, 0.481706,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.3398);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0741007,-99) , 
18, 3.40406, 0, 0, 0.595067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.273595,-99) , 
20, 45.8137, 0, 0, 0.410832,-99) , 
14, 30.9951, 1, 0, 0.45477,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.315749);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415528,-99) , 
24, 0.00228506, 1, 0, 0.52041,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.189684,-99) , 
28, 26.9401, 1, 0, 0.314828,-99) , 
21, 42.6882, 0, 0, 0.471058,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.29009);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.189283,-99) , 
5, -1.57024, 0, 0, 0.5144,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.17169,-99) , 
45, 3.06314, 1, 0, 0.292557,-99) , 
45, 2.93891, 1, 0, 0.463601,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.275081);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45057,-99) , 
20, 49.7723, 0, 0, 0.512837,-99) , 
NN(
0, 
0, 
-1, -2.9389, 0, -1, 0.361882,-99) , 
16, 35.7672, 0, 0, 0.425577,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.292582);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367966,-99) , 
41, 0.935481, 1, 0, 0.584026,-99) , 
NN(
0, 
0, 
-1, -2.9389, 0, -1, 0.390594,-99) , 
22, 14.9859, 0, 0, 0.471123,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.111702);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.991144,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275545,-99) , 
18, 14.1342, 1, 0, 0.881011,-99) , 
NN(
0, 
0, 
-1, 26.432, 1, -1, 0.47021,-99) , 
42, 0.289371, 0, 0, 0.486452,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.282583);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.141409,-99) , 
21, 34.5534, 0, 0, 0.56795,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.732191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331338,-99) , 
27, 17.5654, 1, 0, 0.373842,-99) , 
25, 0.00506119, 1, 0, 0.518794,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.182584);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528215,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0461215,-99) , 
19, 29.1707, 1, 0, 0.510424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.217785,-99) , 
18, 3.64287, 0, 0, 0.471651,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.300442);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360196,-99) , 
23, 22.0618, 1, 0, 0.503674,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206502,-99) , 
22, 7.94864, 1, 0, 0.26491,-99) , 
18, 5.44586, 0, 0, 0.45694,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.142018);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 33.2774, 1, -1, 0.469509,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0945204,-99) , 
40, -0.620557, 0, 0, 0.140623,-99) , 
46, 2.93889, 1, 0, 0.442675,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.281434);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389228,-99) , 
20, 44.1543, 1, 0, 0.593699,-99) , 
NN(
0, 
0, 
-1, 32.372, 0, -1, 0.401697,-99) , 
17, 32.662, 1, 0, 0.442643,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.165702);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.54079, 0, 1, 0.679485,-99) , 
NN(
0, 
0, 
-1, 2.93881, 1, -1, 0.457329,-99) , 
17, 47.5633, 0, 0, 0.499444,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.18759);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470733,-99) , 
21, 50.861, 0, 0, 0.519456,-99) , 
NN(
0, 
0, 
-1, 14.4062, 1, -1, 0.0628427,-99) , 
19, 27.8013, 1, 0, 0.502772,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.306934);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 31.9094, 1, 0, 0.560939,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799087,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307994,-99) , 
48, 3.09753, 1, 0, 0.367764,-99) , 
18, 7.1697, 0, 0, 0.504179,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.204019);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420779,-99) , 
51, 26.9445, 1, 0, 0.507298,-99) , 
NN(
0, 
0, 
-1, 43.0763, 0, -1, 0.248462,-99) , 
46, 2.93889, 1, 0, 0.487809,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.158146);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477213,-99) , 
13, 31.2073, 0, 0, 0.532599,-99) , 
NN(
0, 
0, 
-1, 0.223939, 0, -1, 0.026727,-99) , 
19, 31.9093, 1, 0, 0.522411,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.167221);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322331,-99) , 
21, 41.6747, 0, 0, 0.492189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.266692,-99) , 
18, 3.64443, 0, 0, 0.468068,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.323614);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.734174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375711,-99) , 
2, -1.51693, 0, 0, 0.62188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390873,-99) , 
3, 0.741072, 0, 0, 0.437501,-99) , 
0, 0.808768, 0, 0, 0.492588,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.197834);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 10.6542, 1, 1, 0.633168,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336764,-99) , 
45, -2.53354, 0, 0, 0.446341,-99) , 
13, 37.0777, 0, 0, 0.487942,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.197564);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.540195, 1, 1, 0.539376,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.255459,-99) , 
18, 19.6392, 0, 0, 0.341205,-99) , 
40, -0.677404, 0, 0, 0.493532,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.207275);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277957,-99) , 
33, 0.611195, 0, 0, 0.499264,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.12767,-99) , 
41, -0.750836, 0, 0, 0.213166,-99) , 
47, -2.93886, 0, 0, 0.468445,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.222158);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.831425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.325592,-99) , 
18, 17.9242, 1, 0, 0.650354,-99) , 
NN(
0, 
0, 
-1, 0.194357, 0, -1, 0.43965,-99) , 
42, 0.14468, 0, 0, 0.470218,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0793817);
  fForest.push_back( 
NN(
0, 
0, 
-1, 32.3646, 1, -1, 0.466972,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.272913);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400904,-99) , 
43, 0.0042192, 1, 0, 0.573866,-99) , 
NN(
0, 
0, 
-1, 2.93889, 1, -1, 0.413154,-99) , 
30, 0.101313, 1, 0, 0.501165,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.138277);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.737614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4551,-99) , 
23, 28.2312, 1, 0, 0.663594,-99) , 
NN(
0, 
0, 
-1, 31.9093, 1, -1, 0.484301,-99) , 
27, 42.421, 0, 0, 0.527876,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.233079);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0273828,-99) , 
51, 35.8454, 1, 0, 0.5509,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0202689,-99) , 
49, 0.360185, 0, 0, 0.315129,-99) , 
20, 30.8766, 0, 0, 0.520203,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.264131);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317326,-99) , 
5, -1.40047, 0, 0, 0.538817,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.693775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.233834,-99) , 
41, -0.738311, 0, 0, 0.360338,-99) , 
50, 0.191944, 0, 0, 0.505722,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.339441);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.683538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40303,-99) , 
18, 12.5366, 1, 0, 0.506755,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290321,-99) , 
44, 0.168697, 0, 0, 0.376168,-99) , 
20, 47.4724, 0, 0, 0.43494,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.153128);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 32.6821, 1, -1, 0.477067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.691066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.193909,-99) , 
35, 0.982918, 1, 0, 0.284738,-99) , 
50, 0.193153, 0, 0, 0.447334,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.133053);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.16326,-99) , 
19, 26.4321, 1, 0, 0.496435,-99) , 
NN(
0, 
0, 
-1, -0.741859, 0, -1, 0.288026,-99) , 
21, 42.6882, 0, 0, 0.460258,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.115352);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362945,-99) , 
41, -0.741902, 0, 0, 0.46824,-99) , 
NN(
0, 
0, 
-1, 1.13, 0, -1, 0.0303058,-99) , 
22, 2.51639, 0, 0, 0.459901,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.184015);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40307,-99) , 
12, 9.77798, 0, 0, 0.473037,-99) , 
NN(
0, 
0, 
-1, 44.6622, 0, -1, 0.211338,-99) , 
46, 2.93889, 1, 0, 0.453575,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.051631);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.865378,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499387,-99) , 
2, 2.77643, 0, 0, 0.511597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 33.2788, 1, 0, 0.502442,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.154379);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612238,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479429,-99) , 
1, -0.120895, 1, 0, 0.529234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 31.9093, 1, 0, 0.518502,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.110682);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0337616,-99) , 
19, 29.1708, 1, 0, 0.50748,-99) , 
NN(
0, 
0, 
-1, 16.5411, 1, -1, 0.174279,-99) , 
31, 2.93887, 1, 0, 0.489787,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.179118);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451728,-99) , 
27, 20.9033, 1, 0, 0.476488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0591393,-99) , 
29, 12.7337, 1, 0, 0.147536,-99) , 
51, 36.2031, 1, 0, 0.463637,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.13784);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628219,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47726,-99) , 
19, 11.3693, 1, 0, 0.507408,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.076383,-99) , 
20, 20.9248, 1, 0, 0.178888,-99) , 
51, 37.3331, 1, 0, 0.493297,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.110438);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.070317,-99) , 
51, 37.3334, 1, 0, 0.492477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.693748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.141782,-99) , 
40, -0.683053, 0, 0, 0.199099,-99) , 
46, 2.93889, 1, 0, 0.470555,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.100059);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0443908,-99) , 
29, 32.1099, 1, 0, 0.497075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0393444,-99) , 
28, 44.5869, 0, 0, 0.235039,-99) , 
46, 2.93889, 1, 0, 0.477398,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.213739);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.268938,-99) , 
21, 38.2431, 0, 0, 0.557212,-99) , 
NN(
0, 
0, 
-1, 3.60994, 0, -1, 0.417445,-99) , 
51, 25.7696, 1, 0, 0.478687,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.159314);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432521,-99) , 
22, 14.5411, 1, 0, 0.499395,-99) , 
NN(
0, 
0, 
-1, 13.4332, 0, -1, 0.00403536,-99) , 
22, 1.22258, 0, 0, 0.492295,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.190172);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44902,-99) , 
6, 0.497196, 0, 0, 0.498626,-99) , 
NN(
0, 
0, 
-1, 1.11364, 0, -1, 0.238638,-99) , 
21, 37.9911, 0, 0, 0.481555,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0882109);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0796848,-99) , 
18, 32.0538, 1, 0, 0.50918,-99) , 
NN(
0, 
0, 
-1, -0.541888, 0, -1, 0.258928,-99) , 
21, 36.6651, 0, 0, 0.493177,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0883141);
  fForest.push_back( 
NN(
0, 
0, 
-1, 31.9094, 1, -1, 0.463269,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.207587);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437672,-99) , 
12, 9.78174, 0, 0, 0.511566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.200416,-99) , 
14, 26.3404, 1, 0, 0.299321,-99) , 
51, 30.4163, 1, 0, 0.485106,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.193067);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562317,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 31.9093, 1, 0, 0.55262,-99) , 
NN(
0, 
0, 
-1, -2.93871, 0, -1, 0.408926,-99) , 
36, -0.0956329, 0, 0, 0.485592,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0925022);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327079,-99) , 
47, 2.93876, 1, 0, 0.497108,-99) , 
NN(
0, 
0, 
-1, -0.585514, 1, -1, 0.0138323,-99) , 
22, 1.2444, 0, 0, 0.490702,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.108482);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.720744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473669,-99) , 
42, 0.176755, 0, 0, 0.489967,-99) , 
NN(
0, 
0, 
-1, 0.160756, 0, -1, 0.0118802,-99) , 
22, 1.30481, 0, 0, 0.483661,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0679781);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.841323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484429,-99) , 
42, 0.289221, 0, 0, 0.491835,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
22, 1.23265, 0, 0, 0.485696,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.153676);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 38.1313, 0, 1, 0.540589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616329,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.234683,-99) , 
39, -0.86183, 1, 0, 0.347671,-99) , 
12, 16.3548, 1, 0, 0.515922,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.16805);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471903,-99) , 
47, -1.17355, 1, 0, 0.507387,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.173668,-99) , 
10, -0.405349, 1, 0, 0.256473,-99) , 
47, -2.93885, 0, 0, 0.485424,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.214779);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.164842,-99) , 
51, 36.0332, 1, 0, 0.537005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261941,-99) , 
51, 21.1577, 1, 0, 0.317148,-99) , 
50, 0.193153, 0, 0, 0.500746,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.142643);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.143541, 1, 1, 0.554983,-99) , 
NN(
0, 
0, 
-1, 10.3074, 0, -1, 0.438868,-99) , 
42, 0.112533, 0, 0, 0.476175,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.155524);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.709868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488658,-99) , 
20, 48.0857, 0, 0, 0.610897,-99) , 
NN(
0, 
0, 
-1, 7.23169, 0, -1, 0.445876,-99) , 
13, 38.4225, 0, 0, 0.471318,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.153698);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277111,-99) , 
21, 37.8073, 0, 0, 0.524553,-99) , 
NN(
0, 
0, 
-1, 17.8197, 1, -1, 0.29389,-99) , 
19, 22.3241, 1, 0, 0.506324,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.118958);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480388,-99) , 
32, -0.912039, 1, 0, 0.519461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 33.2787, 1, 0, 0.51374,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.118866);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.783304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479943,-99) , 
46, 2.54646, 0, 0, 0.49774,-99) , 
NN(
0, 
0, 
-1, 9.87728, 0, -1, 0.253065,-99) , 
46, 2.93886, 1, 0, 0.481694,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.126826);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384112,-99) , 
45, 2.93891, 1, 0, 0.494792,-99) , 
NN(
0, 
0, 
-1, 0.303813, 0, -1, 0.222964,-99) , 
32, -2.93886, 0, 0, 0.482858,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.2197);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285833,-99) , 
42, 0.0481997, 0, 0, 0.586802,-99) , 
NN(
0, 
0, 
-1, 42.4952, 0, -1, 0.438641,-99) , 
14, 35.9367, 1, 0, 0.49098,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.164728);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.911652, 0, 1, 0.813945,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424364,-99) , 
46, 0.304036, 1, 0, 0.500643,-99) , 
10, -1.25497, 1, 0, 0.516451,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.128992);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.824935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491294,-99) , 
23, 18.0646, 1, 0, 0.661525,-99) , 
NN(
0, 
0, 
-1, 3.55615, 0, -1, 0.465216,-99) , 
14, 45.9129, 0, 0, 0.492437,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.107836);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 31.9038, 1, 0, 0.528613,-99) , 
NN(
0, 
0, 
-1, 14.0086, 0, -1, 0.021605,-99) , 
22, 2.49298, 0, 0, 0.521258,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0846461);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.371212, 1, 1, 0.720066,-99) , 
NN(
0, 
0, 
-1, 34.9051, 1, -1, 0.482923,-99) , 
14, 21.5098, 1, 0, 0.504108,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.113338);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.851844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.216467,-99) , 
18, 18.0726, 1, 0, 0.71942,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272329,-99) , 
21, 37.9909, 0, 0, 0.496778,-99) , 
24, -0.00598206, 1, 0, 0.512243,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.19681);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.143783,-99) , 
51, 36.2032, 1, 0, 0.524834,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.12754,-99) , 
45, 3.10891, 1, 0, 0.37142,-99) , 
45, 2.93891, 1, 0, 0.493641,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.137222);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42204,-99) , 
42, 0.0964188, 0, 0, 0.463936,-99) , 
NN(
0, 
0, 
-1, 11.898, 0, -1, 0.0214014,-99) , 
22, 1.30527, 0, 0, 0.458591,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.208608);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421531,-99) , 
45, -2.53352, 0, 0, 0.502379,-99) , 
NN(
0, 
0, 
-1, 0.00456172, 1, -1, 0.346054,-99) , 
39, -0.758208, 1, 0, 0.478384,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.233344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395461,-99) , 
20, 42.4879, 0, 0, 0.545423,-99) , 
NN(
0, 
0, 
-1, 5.39746, 0, -1, 0.416671,-99) , 
49, 1.83461, 1, 0, 0.462518,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.165976);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 36.2007, 0, 1, 0.572528,-99) , 
NN(
0, 
0, 
-1, 32.5371, 0, -1, 0.43416,-99) , 
50, 0.971784, 1, 0, 0.493723,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.18083);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.967384,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367801,-99) , 
18, 19.2524, 1, 0, 0.85516,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413342,-99) , 
27, 37.4376, 0, 0, 0.475224,-99) , 
42, 0.28936, 0, 0, 0.485912,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.162826);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370281,-99) , 
51, 30.3766, 1, 0, 0.526473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338801,-99) , 
18, 3.61776, 0, 0, 0.507455,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.176079);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.728677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435905,-99) , 
28, 41.2119, 0, 0, 0.568756,-99) , 
NN(
0, 
0, 
-1, 3.12643, 1, -1, 0.440026,-99) , 
44, 0.0978226, 1, 0, 0.461052,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.106318);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.196733,-99) , 
23, 2.37524, 0, 0, 0.662679,-99) , 
NN(
0, 
0, 
-1, 35.022, 1, -1, 0.467698,-99) , 
14, 21.5106, 1, 0, 0.480677,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.160122);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 37.5138, 1, 1, 0.560901,-99) , 
NN(
0, 
0, 
-1, 6.9211, 0, -1, 0.128575,-99) , 
22, 3.96817, 0, 0, 0.55335,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.124647);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.985856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372792,-99) , 
18, 14.1836, 1, 0, 0.878452,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331121,-99) , 
47, -2.93883, 0, 0, 0.503766,-99) , 
42, 0.289371, 0, 0, 0.515391,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0948067);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.359402,-99) , 
33, 2.62177, 1, 0, 0.504939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
19, 31.9095, 1, 0, 0.499465,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0756812);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.838291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483406,-99) , 
42, 0.28936, 0, 0, 0.492225,-99) , 
NN(
0, 
0, 
-1, 0.00543482, 0, -1, 0.00960395,-99) , 
19, 29.1708, 1, 0, 0.485073,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.105649);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 13.1363, 0, 1, 0.705692,-99) , 
NN(
0, 
0, 
-1, 20.9547, 1, -1, 0.477604,-99) , 
39, -0.896368, 1, 0, 0.504372,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.1543);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54254,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357252,-99) , 
24, 0.00424798, 1, 0, 0.520949,-99) , 
NN(
0, 
0, 
-1, 5.00149, 0, -1, 0.398376,-99) , 
32, -1.92545, 0, 0, 0.495811,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.204718);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.669431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462932,-99) , 
50, 0.388714, 1, 0, 0.505793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.196422,-99) , 
41, -0.677339, 0, 0, 0.384779,-99) , 
18, 7.23169, 0, 0, 0.475849,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.213182);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545859,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.239551,-99) , 
33, 0.337013, 0, 0, 0.52959,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.324458,-99) , 
48, 3.09753, 1, 0, 0.388084,-99) , 
18, 7.17023, 0, 0, 0.496798,-99)    );
   return;
};

// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
